/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 1.0.0 - 2016-01-08
 * License: MIT
 */
//angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]), angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "uib/template/modal/backdrop.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]), angular.module("ui.bootstrap.collapse", []).directive("uibCollapse", ["$animate", "$injector", function (a, b) { var c = b.has("$animateCss") ? b.get("$animateCss") : null; return { link: function (b, d, e) { function f() { d.removeClass("collapse").addClass("collapsing").attr("aria-expanded", !0).attr("aria-hidden", !1), c ? c(d, { addClass: "in", easing: "ease", to: { height: d[0].scrollHeight + "px" } }).start()["finally"](g) : a.addClass(d, "in", { to: { height: d[0].scrollHeight + "px" } }).then(g) } function g() { d.removeClass("collapsing").addClass("collapse").css({ height: "auto" }) } function h() { return d.hasClass("collapse") || d.hasClass("in") ? (d.css({ height: d[0].scrollHeight + "px" }).removeClass("collapse").addClass("collapsing").attr("aria-expanded", !1).attr("aria-hidden", !0), void (c ? c(d, { removeClass: "in", to: { height: "0" } }).start()["finally"](i) : a.removeClass(d, "in", { to: { height: "0" } }).then(i))) : i() } function i() { d.css({ height: "0" }), d.removeClass("collapsing").addClass("collapse") } b.$eval(e.uibCollapse) || d.addClass("in").addClass("collapse").css({ height: "auto" }), b.$watch(e.uibCollapse, function (a) { a ? h() : f() }) } } }]), angular.module("ui.bootstrap.accordion", ["ui.bootstrap.collapse"]).constant("uibAccordionConfig", { closeOthers: !0 }).controller("UibAccordionController", ["$scope", "$attrs", "uibAccordionConfig", function (a, b, c) { this.groups = [], this.closeOthers = function (d) { var e = angular.isDefined(b.closeOthers) ? a.$eval(b.closeOthers) : c.closeOthers; e && angular.forEach(this.groups, function (a) { a !== d && (a.isOpen = !1) }) }, this.addGroup = function (a) { var b = this; this.groups.push(a), a.$on("$destroy", function (c) { b.removeGroup(a) }) }, this.removeGroup = function (a) { var b = this.groups.indexOf(a); -1 !== b && this.groups.splice(b, 1) } }]).directive("uibAccordion", function () { return { controller: "UibAccordionController", controllerAs: "accordion", transclude: !0, templateUrl: function (a, b) { return b.templateUrl || "uib/template/accordion/accordion.html" } } }).directive("uibAccordionGroup", function () { return { require: "^uibAccordion", transclude: !0, replace: !0, templateUrl: function (a, b) { return b.templateUrl || "uib/template/accordion/accordion-group.html" }, scope: { heading: "@", isOpen: "=?", isDisabled: "=?" }, controller: function () { this.setHeading = function (a) { this.heading = a } }, link: function (a, b, c, d) { d.addGroup(a), a.openClass = c.openClass || "panel-open", a.panelClass = c.panelClass || "panel-default", a.$watch("isOpen", function (c) { b.toggleClass(a.openClass, !!c), c && d.closeOthers(a) }), a.toggleOpen = function (b) { a.isDisabled || b && 32 !== b.which || (a.isOpen = !a.isOpen) } } } }).directive("uibAccordionHeading", function () { return { transclude: !0, template: "", replace: !0, require: "^uibAccordionGroup", link: function (a, b, c, d, e) { d.setHeading(e(a, angular.noop)) } } }).directive("uibAccordionTransclude", function () { return { require: "^uibAccordionGroup", link: function (a, b, c, d) { a.$watch(function () { return d[c.uibAccordionTransclude] }, function (a) { a && (b.find("span").html(""), b.find("span").append(a)) }) } } }), angular.module("ui.bootstrap.alert", []).controller("UibAlertController", ["$scope", "$attrs", "$interpolate", "$timeout", function (a, b, c, d) { a.closeable = !!b.close; var e = angular.isDefined(b.dismissOnTimeout) ? c(b.dismissOnTimeout)(a.$parent) : null; e && d(function () { a.close() }, parseInt(e, 10)) }]).directive("uibAlert", function () { return { controller: "UibAlertController", controllerAs: "alert", templateUrl: function (a, b) { return b.templateUrl || "uib/template/alert/alert.html" }, transclude: !0, replace: !0, scope: { type: "@", close: "&" } } }), angular.module("ui.bootstrap.buttons", []).constant("uibButtonConfig", { activeClass: "active", toggleEvent: "click" }).controller("UibButtonsController", ["uibButtonConfig", function (a) { this.activeClass = a.activeClass || "active", this.toggleEvent = a.toggleEvent || "click" }]).directive("uibBtnRadio", ["$parse", function (a) { return { require: ["uibBtnRadio", "ngModel"], controller: "UibButtonsController", controllerAs: "buttons", link: function (b, c, d, e) { var f = e[0], g = e[1], h = a(d.uibUncheckable); c.find("input").css({ display: "none" }), g.$render = function () { c.toggleClass(f.activeClass, angular.equals(g.$modelValue, b.$eval(d.uibBtnRadio))) }, c.on(f.toggleEvent, function () { if (!d.disabled) { var a = c.hasClass(f.activeClass); (!a || angular.isDefined(d.uncheckable)) && b.$apply(function () { g.$setViewValue(a ? null : b.$eval(d.uibBtnRadio)), g.$render() }) } }), d.uibUncheckable && b.$watch(h, function (a) { d.$set("uncheckable", a ? "" : null) }) } } }]).directive("uibBtnCheckbox", function () { return { require: ["uibBtnCheckbox", "ngModel"], controller: "UibButtonsController", controllerAs: "button", link: function (a, b, c, d) { function e() { return g(c.btnCheckboxTrue, !0) } function f() { return g(c.btnCheckboxFalse, !1) } function g(b, c) { return angular.isDefined(b) ? a.$eval(b) : c } var h = d[0], i = d[1]; b.find("input").css({ display: "none" }), i.$render = function () { b.toggleClass(h.activeClass, angular.equals(i.$modelValue, e())) }, b.on(h.toggleEvent, function () { c.disabled || a.$apply(function () { i.$setViewValue(b.hasClass(h.activeClass) ? f() : e()), i.$render() }) }) } } }), angular.module("ui.bootstrap.carousel", []).controller("UibCarouselController", ["$scope", "$element", "$interval", "$timeout", "$animate", function (a, b, c, d, e) { function f() { for (; s.length;) s.shift() } function g(a) { if (angular.isUndefined(p[a].index)) return p[a]; for (var b = 0, c = p.length; c > b; ++b) if (p[b].index === a) return p[b] } function h(c, d, g) { t || (angular.extend(c, { direction: g, active: !0 }), angular.extend(o.currentSlide || {}, { direction: g, active: !1 }), e.enabled(b) && !a.$currentTransition && c.$element && o.slides.length > 1 && (c.$element.data(q, c.direction), o.currentSlide && o.currentSlide.$element && o.currentSlide.$element.data(q, c.direction), a.$currentTransition = !0, e.on("addClass", c.$element, function (b, c) { if ("close" === c && (a.$currentTransition = null, e.off("addClass", b), s.length)) { var d = s.pop(), g = a.indexOfSlide(d), i = g > o.getCurrentIndex() ? "next" : "prev"; f(), h(d, g, i) } })), o.currentSlide = c, r = d, k()) } function i() { m && (c.cancel(m), m = null) } function j(b) { b.length || (a.$currentTransition = null, f()) } function k() { i(); var b = +a.interval; !isNaN(b) && b > 0 && (m = c(l, b)) } function l() { var b = +a.interval; n && !isNaN(b) && b > 0 && p.length ? a.next() : a.pause() } var m, n, o = this, p = o.slides = a.slides = [], q = "uib-slideDirection", r = -1, s = []; o.currentSlide = null; var t = !1; o.addSlide = function (b, c) { b.$element = c, p.push(b), 1 === p.length || b.active ? (a.$currentTransition && (a.$currentTransition = null), o.select(p[p.length - 1]), 1 === p.length && a.play()) : b.active = !1 }, o.getCurrentIndex = function () { return o.currentSlide && angular.isDefined(o.currentSlide.index) ? +o.currentSlide.index : r }, o.next = a.next = function () { var b = (o.getCurrentIndex() + 1) % p.length; return 0 === b && a.noWrap() ? void a.pause() : o.select(g(b), "next") }, o.prev = a.prev = function () { var b = o.getCurrentIndex() - 1 < 0 ? p.length - 1 : o.getCurrentIndex() - 1; return a.noWrap() && b === p.length - 1 ? void a.pause() : o.select(g(b), "prev") }, o.removeSlide = function (a) { angular.isDefined(a.index) && p.sort(function (a, b) { return +a.index > +b.index }); var b = s.indexOf(a); -1 !== b && s.splice(b, 1); var c = p.indexOf(a); p.splice(c, 1), d(function () { p.length > 0 && a.active ? c >= p.length ? o.select(p[c - 1]) : o.select(p[c]) : r > c && r-- }), 0 === p.length && (o.currentSlide = null, f()) }, o.select = a.select = function (b, c) { var d = a.indexOfSlide(b); void 0 === c && (c = d > o.getCurrentIndex() ? "next" : "prev"), b && b !== o.currentSlide && !a.$currentTransition ? h(b, d, c) : b && b !== o.currentSlide && a.$currentTransition && s.push(b) }, a.indexOfSlide = function (a) { return angular.isDefined(a.index) ? +a.index : p.indexOf(a) }, a.isActive = function (a) { return o.currentSlide === a }, a.pause = function () { a.noPause || (n = !1, i()) }, a.play = function () { n || (n = !0, k()) }, a.$on("$destroy", function () { t = !0, i() }), a.$watch("noTransition", function (a) { e.enabled(b, !a) }), a.$watch("interval", k), a.$watchCollection("slides", j) }]).directive("uibCarousel", function () { return { transclude: !0, replace: !0, controller: "UibCarouselController", controllerAs: "carousel", templateUrl: function (a, b) { return b.templateUrl || "uib/template/carousel/carousel.html" }, scope: { interval: "=", noTransition: "=", noPause: "=", noWrap: "&" } } }).directive("uibSlide", function () { return { require: "^uibCarousel", transclude: !0, replace: !0, templateUrl: function (a, b) { return b.templateUrl || "uib/template/carousel/slide.html" }, scope: { active: "=?", actual: "=?", index: "=?" }, link: function (a, b, c, d) { d.addSlide(a, b), a.$on("$destroy", function () { d.removeSlide(a) }), a.$watch("active", function (b) { b && d.select(a) }) } } }).animation(".item", ["$animateCss", function (a) { function b(a, b, c) { a.removeClass(b), c && c() } var c = "uib-slideDirection"; return { beforeAddClass: function (d, e, f) { if ("active" === e) { var g = !1, h = d.data(c), i = "next" === h ? "left" : "right", j = b.bind(this, d, i + " " + h, f); return d.addClass(h), a(d, { addClass: i }).start().done(j), function () { g = !0 } } f() }, beforeRemoveClass: function (d, e, f) { if ("active" === e) { var g = !1, h = d.data(c), i = "next" === h ? "left" : "right", j = b.bind(this, d, i, f); return a(d, { addClass: i }).start().done(j), function () { g = !0 } } f() } } }]), angular.module("ui.bootstrap.dateparser", []).service("uibDateParser", ["$log", "$locale", "orderByFilter", function (a, b, c) { function d(a) { var b = [], d = a.split(""), e = a.indexOf("'"); if (e > -1) { var f = !1; a = a.split(""); for (var g = e; g < a.length; g++) f ? ("'" === a[g] && (g + 1 < a.length && "'" === a[g + 1] ? (a[g + 1] = "$", d[g + 1] = "") : (d[g] = "", f = !1)), a[g] = "$") : "'" === a[g] && (a[g] = "$", d[g] = "", f = !0); a = a.join("") } return angular.forEach(m, function (c) { var e = a.indexOf(c.key); if (e > -1) { a = a.split(""), d[e] = "(" + c.regex + ")", a[e] = "$"; for (var f = e + 1, g = e + c.key.length; g > f; f++) d[f] = "", a[f] = "$"; a = a.join(""), b.push({ index: e, apply: c.apply, matcher: c.regex }) } }), { regex: new RegExp("^" + d.join("") + "$"), map: c(b, "index") } } function e(a, b, c) { return 1 > c ? !1 : 1 === b && c > 28 ? 29 === c && (a % 4 === 0 && a % 100 !== 0 || a % 400 === 0) : 3 === b || 5 === b || 8 === b || 10 === b ? 31 > c : !0 } function f(a) { return parseInt(a, 10) } function g(a, b) { return a && b ? k(a, b) : a } function h(a, b) { return a && b ? k(a, b, !0) : a } function i(a, b) { var c = Date.parse("Jan 01, 1970 00:00:00 " + a) / 6e4; return isNaN(c) ? b : c } function j(a, b) { return a = new Date(a.getTime()), a.setMinutes(a.getMinutes() + b), a } function k(a, b, c) { c = c ? -1 : 1; var d = i(b, a.getTimezoneOffset()); return j(a, c * (d - a.getTimezoneOffset())) } var l, m, n = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g; this.init = function () { l = b.id, this.parsers = {}, m = [{ key: "yyyy", regex: "\\d{4}", apply: function (a) { this.year = +a } }, { key: "yy", regex: "\\d{2}", apply: function (a) { this.year = +a + 2e3 } }, { key: "y", regex: "\\d{1,4}", apply: function (a) { this.year = +a } }, { key: "M!", regex: "0?[1-9]|1[0-2]", apply: function (a) { this.month = a - 1 } }, { key: "MMMM", regex: b.DATETIME_FORMATS.MONTH.join("|"), apply: function (a) { this.month = b.DATETIME_FORMATS.MONTH.indexOf(a) } }, { key: "MMM", regex: b.DATETIME_FORMATS.SHORTMONTH.join("|"), apply: function (a) { this.month = b.DATETIME_FORMATS.SHORTMONTH.indexOf(a) } }, { key: "MM", regex: "0[1-9]|1[0-2]", apply: function (a) { this.month = a - 1 } }, { key: "M", regex: "[1-9]|1[0-2]", apply: function (a) { this.month = a - 1 } }, { key: "d!", regex: "[0-2]?[0-9]{1}|3[0-1]{1}", apply: function (a) { this.date = +a } }, { key: "dd", regex: "[0-2][0-9]{1}|3[0-1]{1}", apply: function (a) { this.date = +a } }, { key: "d", regex: "[1-2]?[0-9]{1}|3[0-1]{1}", apply: function (a) { this.date = +a } }, { key: "EEEE", regex: b.DATETIME_FORMATS.DAY.join("|") }, { key: "EEE", regex: b.DATETIME_FORMATS.SHORTDAY.join("|") }, { key: "HH", regex: "(?:0|1)[0-9]|2[0-3]", apply: function (a) { this.hours = +a } }, { key: "hh", regex: "0[0-9]|1[0-2]", apply: function (a) { this.hours = +a } }, { key: "H", regex: "1?[0-9]|2[0-3]", apply: function (a) { this.hours = +a } }, { key: "h", regex: "[0-9]|1[0-2]", apply: function (a) { this.hours = +a } }, { key: "mm", regex: "[0-5][0-9]", apply: function (a) { this.minutes = +a } }, { key: "m", regex: "[0-9]|[1-5][0-9]", apply: function (a) { this.minutes = +a } }, { key: "sss", regex: "[0-9][0-9][0-9]", apply: function (a) { this.milliseconds = +a } }, { key: "ss", regex: "[0-5][0-9]", apply: function (a) { this.seconds = +a } }, { key: "s", regex: "[0-9]|[1-5][0-9]", apply: function (a) { this.seconds = +a } }, { key: "a", regex: b.DATETIME_FORMATS.AMPMS.join("|"), apply: function (a) { 12 === this.hours && (this.hours = 0), "PM" === a && (this.hours += 12) } }, { key: "Z", regex: "[+-]\\d{4}", apply: function (a) { var b = a.match(/([+-])(\d{2})(\d{2})/), c = b[1], d = b[2], e = b[3]; this.hours += f(c + d), this.minutes += f(c + e) } }, { key: "ww", regex: "[0-4][0-9]|5[0-3]" }, { key: "w", regex: "[0-9]|[1-4][0-9]|5[0-3]" }, { key: "GGGG", regex: b.DATETIME_FORMATS.ERANAMES.join("|").replace(/\s/g, "\\s") }, { key: "GGG", regex: b.DATETIME_FORMATS.ERAS.join("|") }, { key: "GG", regex: b.DATETIME_FORMATS.ERAS.join("|") }, { key: "G", regex: b.DATETIME_FORMATS.ERAS.join("|") }] }, this.init(), this.parse = function (c, f, g) { if (!angular.isString(c) || !f) return c; f = b.DATETIME_FORMATS[f] || f, f = f.replace(n, "\\$&"), b.id !== l && this.init(), this.parsers[f] || (this.parsers[f] = d(f)); var h = this.parsers[f], i = h.regex, j = h.map, k = c.match(i), m = !1; if (k && k.length) { var o, p; angular.isDate(g) && !isNaN(g.getTime()) ? o = { year: g.getFullYear(), month: g.getMonth(), date: g.getDate(), hours: g.getHours(), minutes: g.getMinutes(), seconds: g.getSeconds(), milliseconds: g.getMilliseconds() } : (g && a.warn("dateparser:", "baseDate is not a valid date"), o = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }); for (var q = 1, r = k.length; r > q; q++) { var s = j[q - 1]; "Z" === s.matcher && (m = !0), s.apply && s.apply.call(o, k[q]) } var t = m ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear, u = m ? Date.prototype.setUTCHours : Date.prototype.setHours; return e(o.year, o.month, o.date) && (!angular.isDate(g) || isNaN(g.getTime()) || m ? (p = new Date(0), t.call(p, o.year, o.month, o.date), u.call(p, o.hours || 0, o.minutes || 0, o.seconds || 0, o.milliseconds || 0)) : (p = new Date(g), t.call(p, o.year, o.month, o.date), u.call(p, o.hours, o.minutes, o.seconds, o.milliseconds))), p } }, this.toTimezone = g, this.fromTimezone = h, this.timezoneToOffset = i, this.addDateMinutes = j, this.convertTimezoneToLocal = k }]), angular.module("ui.bootstrap.isClass", []).directive("uibIsClass", ["$animate", function (a) { var b = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/, c = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/; return { restrict: "A", compile: function (d, e) { function f(a, b, c) { i.push(a), j.push({ scope: a, element: b }), o.forEach(function (b, c) { g(b, a) }), a.$on("$destroy", h) } function g(b, d) { var e = b.match(c), f = d.$eval(e[1]), g = e[2], h = k[b]; if (!h) { var i = function (b) { var c = null; j.some(function (a) { var d = a.scope.$eval(m); return d === b ? (c = a, !0) : void 0 }), h.lastActivated !== c && (h.lastActivated && a.removeClass(h.lastActivated.element, f), c && a.addClass(c.element, f), h.lastActivated = c) }; k[b] = h = { lastActivated: null, scope: d, watchFn: i, compareWithExp: g, watcher: d.$watch(g, i) } } h.watchFn(d.$eval(g)) } function h(a) { var b = a.targetScope, c = i.indexOf(b); if (i.splice(c, 1), j.splice(c, 1), i.length) { var d = i[0]; angular.forEach(k, function (a) { a.scope === b && (a.watcher = d.$watch(a.compareWithExp, a.watchFn), a.scope = d) }) } else k = {} } var i = [], j = [], k = {}, l = e.uibIsClass.match(b), m = l[2], n = l[1], o = n.split(","); return f } } }]), angular.module("ui.bootstrap.position", []).factory("$uibPosition", ["$document", "$window", function (a, b) { var c, d = { normal: /(auto|scroll)/, hidden: /(auto|scroll|hidden)/ }, e = { auto: /\s?auto?\s?/i, primary: /^(top|bottom|left|right)$/, secondary: /^(top|bottom|left|right|center)$/, vertical: /^(top|bottom)$/ }; return { getRawNode: function (a) { return a[0] || a }, parseStyle: function (a) { return a = parseFloat(a), isFinite(a) ? a : 0 }, offsetParent: function (c) { function d(a) { return "static" === (b.getComputedStyle(a).position || "static") } c = this.getRawNode(c); for (var e = c.offsetParent || a[0].documentElement; e && e !== a[0].documentElement && d(e) ;) e = e.offsetParent; return e || a[0].documentElement }, scrollbarWidth: function () { if (angular.isUndefined(c)) { var b = angular.element('<div style="position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;"></div>'); a.find("body").append(b), c = b[0].offsetWidth - b[0].clientWidth, c = isFinite(c) ? c : 0, b.remove() } return c }, scrollParent: function (c, e) { c = this.getRawNode(c); var f = e ? d.hidden : d.normal, g = a[0].documentElement, h = b.getComputedStyle(c), i = "absolute" === h.position, j = c.parentElement || g; if (j === g || "fixed" === h.position) return g; for (; j.parentElement && j !== g;) { var k = b.getComputedStyle(j); if (i && "static" !== k.position && (i = !1), !i && f.test(k.overflow + k.overflowY + k.overflowX)) break; j = j.parentElement } return j }, position: function (c, d) { c = this.getRawNode(c); var e = this.offset(c); if (d) { var f = b.getComputedStyle(c); e.top -= this.parseStyle(f.marginTop), e.left -= this.parseStyle(f.marginLeft) } var g = this.offsetParent(c), h = { top: 0, left: 0 }; return g !== a[0].documentElement && (h = this.offset(g), h.top += g.clientTop - g.scrollTop, h.left += g.clientLeft - g.scrollLeft), { width: Math.round(angular.isNumber(e.width) ? e.width : c.offsetWidth), height: Math.round(angular.isNumber(e.height) ? e.height : c.offsetHeight), top: Math.round(e.top - h.top), left: Math.round(e.left - h.left) } }, offset: function (c) { c = this.getRawNode(c); var d = c.getBoundingClientRect(); return { width: Math.round(angular.isNumber(d.width) ? d.width : c.offsetWidth), height: Math.round(angular.isNumber(d.height) ? d.height : c.offsetHeight), top: Math.round(d.top + (b.pageYOffset || a[0].documentElement.scrollTop)), left: Math.round(d.left + (b.pageXOffset || a[0].documentElement.scrollLeft)) } }, viewportOffset: function (c, d, e) { c = this.getRawNode(c), e = e !== !1 ? !0 : !1; var f = c.getBoundingClientRect(), g = { top: 0, left: 0, bottom: 0, right: 0 }, h = d ? a[0].documentElement : this.scrollParent(c), i = h.getBoundingClientRect(); if (g.top = i.top + h.clientTop, g.left = i.left + h.clientLeft, h === a[0].documentElement && (g.top += b.pageYOffset, g.left += b.pageXOffset), g.bottom = g.top + h.clientHeight, g.right = g.left + h.clientWidth, e) { var j = b.getComputedStyle(h); g.top += this.parseStyle(j.paddingTop), g.bottom -= this.parseStyle(j.paddingBottom), g.left += this.parseStyle(j.paddingLeft), g.right -= this.parseStyle(j.paddingRight) } return { top: Math.round(f.top - g.top), bottom: Math.round(g.bottom - f.bottom), left: Math.round(f.left - g.left), right: Math.round(g.right - f.right) } }, parsePlacement: function (a) { var b = e.auto.test(a); return b && (a = a.replace(e.auto, "")), a = a.split("-"), a[0] = a[0] || "top", e.primary.test(a[0]) || (a[0] = "top"), a[1] = a[1] || "center", e.secondary.test(a[1]) || (a[1] = "center"), b ? a[2] = !0 : a[2] = !1, a }, positionElements: function (a, c, d, f) { a = this.getRawNode(a), c = this.getRawNode(c); var g = angular.isDefined(c.offsetWidth) ? c.offsetWidth : c.prop("offsetWidth"), h = angular.isDefined(c.offsetHeight) ? c.offsetHeight : c.prop("offsetHeight"); d = this.parsePlacement(d); var i = f ? this.offset(a) : this.position(a), j = { top: 0, left: 0, placement: "" }; if (d[2]) { var k = this.viewportOffset(a), l = b.getComputedStyle(c), m = { width: g + Math.round(Math.abs(this.parseStyle(l.marginLeft) + this.parseStyle(l.marginRight))), height: h + Math.round(Math.abs(this.parseStyle(l.marginTop) + this.parseStyle(l.marginBottom))) }; if (d[0] = "top" === d[0] && m.height > k.top && m.height <= k.bottom ? "bottom" : "bottom" === d[0] && m.height > k.bottom && m.height <= k.top ? "top" : "left" === d[0] && m.width > k.left && m.width <= k.right ? "right" : "right" === d[0] && m.width > k.right && m.width <= k.left ? "left" : d[0], d[1] = "top" === d[1] && m.height - i.height > k.bottom && m.height - i.height <= k.top ? "bottom" : "bottom" === d[1] && m.height - i.height > k.top && m.height - i.height <= k.bottom ? "top" : "left" === d[1] && m.width - i.width > k.right && m.width - i.width <= k.left ? "right" : "right" === d[1] && m.width - i.width > k.left && m.width - i.width <= k.right ? "left" : d[1], "center" === d[1]) if (e.vertical.test(d[0])) { var n = i.width / 2 - g / 2; k.left + n < 0 && m.width - i.width <= k.right ? d[1] = "left" : k.right + n < 0 && m.width - i.width <= k.left && (d[1] = "right") } else { var o = i.height / 2 - m.height / 2; k.top + o < 0 && m.height - i.height <= k.bottom ? d[1] = "top" : k.bottom + o < 0 && m.height - i.height <= k.top && (d[1] = "bottom") } } switch (d[0]) { case "top": j.top = i.top - h; break; case "bottom": j.top = i.top + i.height; break; case "left": j.left = i.left - g; break; case "right": j.left = i.left + i.width } switch (d[1]) { case "top": j.top = i.top; break; case "bottom": j.top = i.top + i.height - h; break; case "left": j.left = i.left; break; case "right": j.left = i.left + i.width - g; break; case "center": e.vertical.test(d[0]) ? j.left = i.left + i.width / 2 - g / 2 : j.top = i.top + i.height / 2 - h / 2 } return j.top = Math.round(j.top), j.left = Math.round(j.left), j.placement = "center" === d[1] ? d[0] : d[0] + "-" + d[1], j }, positionArrow: function (a, c) { a = this.getRawNode(a); var d = !0, f = a.querySelector(".tooltip-inner"); if (f || (d = !1, f = a.querySelector(".popover-inner")), f) { var g = d ? a.querySelector(".tooltip-arrow") : a.querySelector(".arrow"); if (g) { if (c = this.parsePlacement(c), "center" === c[1]) return void angular.element(g).css({ top: "", bottom: "", right: "", left: "", margin: "" }); var h = "border-" + c[0] + "-width", i = b.getComputedStyle(g)[h], j = "border-"; j += e.vertical.test(c[0]) ? c[0] + "-" + c[1] : c[1] + "-" + c[0], j += "-radius"; var k = b.getComputedStyle(d ? f : a)[j], l = { top: "auto", bottom: "auto", left: "auto", right: "auto", margin: 0 }; switch (c[0]) { case "top": l.bottom = d ? "0" : "-" + i; break; case "bottom": l.top = d ? "0" : "-" + i; break; case "left": l.right = d ? "0" : "-" + i; break; case "right": l.left = d ? "0" : "-" + i } l[c[1]] = k, angular.element(g).css(l) } } } } }]), angular.module("ui.bootstrap.datepicker", ["ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.position"]).value("$datepickerSuppressError", !1).constant("uibDatepickerConfig", { formatDay: "dd", formatMonth: "MMMM", formatYear: "yyyy", formatDayHeader: "EEE", formatDayTitle: "MMMM yyyy", formatMonthTitle: "yyyy", datepickerMode: "day", minMode: "day", maxMode: "year", showWeeks: !0, startingDay: 0, yearRows: 4, yearColumns: 5, minDate: null, maxDate: null, shortcutPropagation: !1, ngModelOptions: {} }).controller("UibDatepickerController", ["$scope", "$attrs", "$parse", "$interpolate", "$log", "dateFilter", "uibDatepickerConfig", "$datepickerSuppressError", "uibDateParser", function (a, b, c, d, e, f, g, h, i) { var j = this, k = { $setViewValue: angular.noop }, l = {}; this.modes = ["day", "month", "year"], angular.forEach(["formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle"], function (c) { j[c] = angular.isDefined(b[c]) ? d(b[c])(a.$parent) : g[c] }), angular.forEach(["showWeeks", "startingDay", "yearRows", "yearColumns", "shortcutPropagation"], function (c) { j[c] = angular.isDefined(b[c]) ? a.$parent.$eval(b[c]) : g[c] }), angular.forEach(["minDate", "maxDate"], function (c) { b[c] ? a.$parent.$watch(b[c], function (a) { j[c] = a ? angular.isDate(a) ? i.fromTimezone(new Date(a), l.timezone) : new Date(f(a, "medium")) : null, j.refreshView() }) : j[c] = g[c] ? i.fromTimezone(new Date(g[c]), l.timezone) : null }), angular.forEach(["minMode", "maxMode"], function (c) { b[c] ? a.$parent.$watch(b[c], function (d) { j[c] = a[c] = angular.isDefined(d) ? d : b[c], ("minMode" === c && j.modes.indexOf(a.datepickerMode) < j.modes.indexOf(j[c]) || "maxMode" === c && j.modes.indexOf(a.datepickerMode) > j.modes.indexOf(j[c])) && (a.datepickerMode = j[c]) }) : j[c] = a[c] = g[c] || null }), a.datepickerMode = a.datepickerMode || g.datepickerMode, a.uniqueId = "datepicker-" + a.$id + "-" + Math.floor(1e4 * Math.random()), angular.isDefined(b.initDate) ? (this.activeDate = i.fromTimezone(a.$parent.$eval(b.initDate), l.timezone) || new Date, a.$parent.$watch(b.initDate, function (a) { a && (k.$isEmpty(k.$modelValue) || k.$invalid) && (j.activeDate = i.fromTimezone(a, l.timezone), j.refreshView()) })) : this.activeDate = new Date, a.disabled = angular.isDefined(b.disabled) || !1, angular.isDefined(b.ngDisabled) && a.$parent.$watch(b.ngDisabled, function (b) { a.disabled = b, j.refreshView() }), a.isActive = function (b) { return 0 === j.compare(b.date, j.activeDate) ? (a.activeDateId = b.uid, !0) : !1 }, this.init = function (a) { k = a, l = a.$options || g.ngModelOptions, k.$modelValue && (this.activeDate = k.$modelValue), k.$render = function () { j.render() } }, this.render = function () { if (k.$viewValue) { var a = new Date(k.$viewValue), b = !isNaN(a); b ? this.activeDate = i.fromTimezone(a, l.timezone) : h || e.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.') } this.refreshView() }, this.refreshView = function () { if (this.element) { a.selectedDt = null, this._refreshView(), a.activeDt && (a.activeDateId = a.activeDt.uid); var b = k.$viewValue ? new Date(k.$viewValue) : null; b = i.fromTimezone(b, l.timezone), k.$setValidity("dateDisabled", !b || this.element && !this.isDisabled(b)) } }, this.createDateObject = function (b, c) { var d = k.$viewValue ? new Date(k.$viewValue) : null; d = i.fromTimezone(d, l.timezone); var e = { date: b, label: f(b, c), selected: d && 0 === this.compare(b, d), disabled: this.isDisabled(b), current: 0 === this.compare(b, new Date), customClass: this.customClass(b) || null }; return d && 0 === this.compare(b, d) && (a.selectedDt = e), j.activeDate && 0 === this.compare(e.date, j.activeDate) && (a.activeDt = e), e }, this.isDisabled = function (c) { return a.disabled || this.minDate && this.compare(c, this.minDate) < 0 || this.maxDate && this.compare(c, this.maxDate) > 0 || b.dateDisabled && a.dateDisabled({ date: c, mode: a.datepickerMode }) }, this.customClass = function (b) { return a.customClass({ date: b, mode: a.datepickerMode }) }, this.split = function (a, b) { for (var c = []; a.length > 0;) c.push(a.splice(0, b)); return c }, a.select = function (b) { if (a.datepickerMode === j.minMode) { var c = k.$viewValue ? i.fromTimezone(new Date(k.$viewValue), l.timezone) : new Date(0, 0, 0, 0, 0, 0, 0); c.setFullYear(b.getFullYear(), b.getMonth(), b.getDate()), c = i.toTimezone(c, l.timezone), k.$setViewValue(c), k.$render() } else j.activeDate = b, a.datepickerMode = j.modes[j.modes.indexOf(a.datepickerMode) - 1] }, a.move = function (a) { var b = j.activeDate.getFullYear() + a * (j.step.years || 0), c = j.activeDate.getMonth() + a * (j.step.months || 0); j.activeDate.setFullYear(b, c, 1), j.refreshView() }, a.toggleMode = function (b) { b = b || 1, a.datepickerMode === j.maxMode && 1 === b || a.datepickerMode === j.minMode && -1 === b || (a.datepickerMode = j.modes[j.modes.indexOf(a.datepickerMode) + b]) }, a.keys = { 13: "enter", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home", 37: "left", 38: "up", 39: "right", 40: "down" }; var m = function () { j.element[0].focus() }; a.$on("uib:datepicker.focus", m), a.keydown = function (b) { var c = a.keys[b.which]; if (c && !b.shiftKey && !b.altKey && !a.disabled) if (b.preventDefault(), j.shortcutPropagation || b.stopPropagation(), "enter" === c || "space" === c) { if (j.isDisabled(j.activeDate)) return; a.select(j.activeDate) } else !b.ctrlKey || "up" !== c && "down" !== c ? (j.handleKeyDown(c, b), j.refreshView()) : a.toggleMode("up" === c ? 1 : -1) } }]).controller("UibDaypickerController", ["$scope", "$element", "dateFilter", function (a, b, c) { function d(a, b) { return 1 !== b || a % 4 !== 0 || a % 100 === 0 && a % 400 !== 0 ? f[b] : 29 } function e(a) { var b = new Date(a); b.setDate(b.getDate() + 4 - (b.getDay() || 7)); var c = b.getTime(); return b.setMonth(0), b.setDate(1), Math.floor(Math.round((c - b) / 864e5) / 7) + 1 } var f = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; this.step = { months: 1 }, this.element = b, this.init = function (b) { angular.extend(b, this), a.showWeeks = b.showWeeks, b.refreshView() }, this.getDates = function (a, b) { for (var c, d = new Array(b), e = new Date(a), f = 0; b > f;) c = new Date(e), d[f++] = c, e.setDate(e.getDate() + 1); return d }, this._refreshView = function () { var b = this.activeDate.getFullYear(), d = this.activeDate.getMonth(), f = new Date(this.activeDate); f.setFullYear(b, d, 1); var g = this.startingDay - f.getDay(), h = g > 0 ? 7 - g : -g, i = new Date(f); h > 0 && i.setDate(-h + 1); for (var j = this.getDates(i, 42), k = 0; 42 > k; k++) j[k] = angular.extend(this.createDateObject(j[k], this.formatDay), { secondary: j[k].getMonth() !== d, uid: a.uniqueId + "-" + k }); a.labels = new Array(7); for (var l = 0; 7 > l; l++) a.labels[l] = { abbr: c(j[l].date, this.formatDayHeader), full: c(j[l].date, "EEEE") }; if (a.title = c(this.activeDate, this.formatDayTitle), a.rows = this.split(j, 7), a.showWeeks) { a.weekNumbers = []; for (var m = (11 - this.startingDay) % 7, n = a.rows.length, o = 0; n > o; o++) a.weekNumbers.push(e(a.rows[o][m].date)) } }, this.compare = function (a, b) { var c = new Date(a.getFullYear(), a.getMonth(), a.getDate()), d = new Date(b.getFullYear(), b.getMonth(), b.getDate()); return c.setFullYear(a.getFullYear()), d.setFullYear(b.getFullYear()), c - d }, this.handleKeyDown = function (a, b) { var c = this.activeDate.getDate(); if ("left" === a) c -= 1; else if ("up" === a) c -= 7; else if ("right" === a) c += 1; else if ("down" === a) c += 7; else if ("pageup" === a || "pagedown" === a) { var e = this.activeDate.getMonth() + ("pageup" === a ? -1 : 1); this.activeDate.setMonth(e, 1), c = Math.min(d(this.activeDate.getFullYear(), this.activeDate.getMonth()), c) } else "home" === a ? c = 1 : "end" === a && (c = d(this.activeDate.getFullYear(), this.activeDate.getMonth())); this.activeDate.setDate(c) } }]).controller("UibMonthpickerController", ["$scope", "$element", "dateFilter", function (a, b, c) { this.step = { years: 1 }, this.element = b, this.init = function (a) { angular.extend(a, this), a.refreshView() }, this._refreshView = function () { for (var b, d = new Array(12), e = this.activeDate.getFullYear(), f = 0; 12 > f; f++) b = new Date(this.activeDate), b.setFullYear(e, f, 1), d[f] = angular.extend(this.createDateObject(b, this.formatMonth), { uid: a.uniqueId + "-" + f }); a.title = c(this.activeDate, this.formatMonthTitle), a.rows = this.split(d, 3) }, this.compare = function (a, b) { var c = new Date(a.getFullYear(), a.getMonth()), d = new Date(b.getFullYear(), b.getMonth()); return c.setFullYear(a.getFullYear()), d.setFullYear(b.getFullYear()), c - d }, this.handleKeyDown = function (a, b) { var c = this.activeDate.getMonth(); if ("left" === a) c -= 1; else if ("up" === a) c -= 3; else if ("right" === a) c += 1; else if ("down" === a) c += 3; else if ("pageup" === a || "pagedown" === a) { var d = this.activeDate.getFullYear() + ("pageup" === a ? -1 : 1); this.activeDate.setFullYear(d) } else "home" === a ? c = 0 : "end" === a && (c = 11); this.activeDate.setMonth(c) } }]).controller("UibYearpickerController", ["$scope", "$element", "dateFilter", function (a, b, c) { function d(a) { return parseInt((a - 1) / f, 10) * f + 1 } var e, f; this.element = b, this.yearpickerInit = function () { e = this.yearColumns, f = this.yearRows * e, this.step = { years: f } }, this._refreshView = function () { for (var b, c = new Array(f), g = 0, h = d(this.activeDate.getFullYear()) ; f > g; g++) b = new Date(this.activeDate), b.setFullYear(h + g, 0, 1), c[g] = angular.extend(this.createDateObject(b, this.formatYear), { uid: a.uniqueId + "-" + g }); a.title = [c[0].label, c[f - 1].label].join(" - "), a.rows = this.split(c, e), a.columns = e }, this.compare = function (a, b) { return a.getFullYear() - b.getFullYear() }, this.handleKeyDown = function (a, b) { var c = this.activeDate.getFullYear(); "left" === a ? c -= 1 : "up" === a ? c -= e : "right" === a ? c += 1 : "down" === a ? c += e : "pageup" === a || "pagedown" === a ? c += ("pageup" === a ? -1 : 1) * f : "home" === a ? c = d(this.activeDate.getFullYear()) : "end" === a && (c = d(this.activeDate.getFullYear()) + f - 1), this.activeDate.setFullYear(c) } }]).directive("uibDatepicker", function () { return { replace: !0, templateUrl: function (a, b) { return b.templateUrl || "template/datepicker/datepicker.html" }, scope: { datepickerMode: "=?", dateDisabled: "&", customClass: "&", shortcutPropagation: "&?" }, require: ["uibDatepicker", "^ngModel"], controller: "UibDatepickerController", controllerAs: "datepicker", link: function (a, b, c, d) { var e = d[0], f = d[1]; e.init(f) } } }).directive("uibDaypicker", function () { return { replace: !0, templateUrl: function (a, b) { return b.templateUrl || "template/datepicker/day.html" }, require: ["^uibDatepicker", "uibDaypicker"], controller: "UibDaypickerController", link: function (a, b, c, d) { var e = d[0], f = d[1]; f.init(e) } } }).directive("uibMonthpicker", function () { return { replace: !0, templateUrl: function (a, b) { return b.templateUrl || "template/datepicker/month.html" }, require: ["^uibDatepicker", "uibMonthpicker"], controller: "UibMonthpickerController", link: function (a, b, c, d) { var e = d[0], f = d[1]; f.init(e) } } }).directive("uibYearpicker", function () {
//    return { replace: !0, templateUrl: function (a, b) { return b.templateUrl || "template/datepicker/year.html" }, require: ["^uibDatepicker", "uibYearpicker"], controller: "UibYearpickerController", link: function (a, b, c, d) { var e = d[0]; angular.extend(e, d[1]), e.yearpickerInit(), e.refreshView() } }
//}).constant("uibDatepickerPopupConfig", { datepickerPopup: "yyyy-MM-dd", datepickerPopupTemplateUrl: "template/datepicker/popup.html", datepickerTemplateUrl: "template/datepicker/datepicker.html", html5Types: { date: "yyyy-MM-dd", "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss", month: "yyyy-MM" }, currentText: "Today", clearText: "Clear", closeText: "Done", closeOnDateSelection: !0, appendToBody: !1, showButtonBar: !0, onOpenFocus: !0, altInputFormats: [] }).controller("UibDatepickerPopupController", ["$scope", "$element", "$attrs", "$compile", "$parse", "$document", "$rootScope", "$uibPosition", "dateFilter", "uibDateParser", "uibDatepickerPopupConfig", "$timeout", "uibDatepickerConfig", function (a, b, c, d, e, f, g, h, i, j, k, l, m) { function n(a) { return a.replace(/([A-Z])/g, function (a) { return "-" + a.toLowerCase() }) } function o(b) { var c = j.parse(b, t, a.date); if (isNaN(c)) for (var d = 0; d < E.length; d++) if (c = j.parse(b, E[d], a.date), !isNaN(c)) return c; return c } function p(a) { if (angular.isNumber(a) && (a = new Date(a)), !a) return null; if (angular.isDate(a) && !isNaN(a)) return a; if (angular.isString(a)) { var b = o(a); if (!isNaN(b)) return j.toTimezone(b, C.timezone) } return B.$options && B.$options.allowInvalid ? a : void 0 } function q(a, b) { var d = a || b; return c.ngRequired || d ? (angular.isNumber(d) && (d = new Date(d)), d ? angular.isDate(d) && !isNaN(d) ? !0 : angular.isString(d) ? !isNaN(o(b)) : !1 : !0) : !0 } function r(c) { if (a.isOpen || !a.disabled) { var d = D[0], e = b[0].contains(c.target), f = void 0 !== d.contains && d.contains(c.target); !a.isOpen || e || f || a.$apply(function () { a.isOpen = !1 }) } } function s(c) { 27 === c.which && a.isOpen ? (c.preventDefault(), c.stopPropagation(), a.$apply(function () { a.isOpen = !1 }), b[0].focus()) : 40 !== c.which || a.isOpen || (c.preventDefault(), c.stopPropagation(), a.$apply(function () { a.isOpen = !0 })) } var t, u, v, w, x, y, z, A, B, C, D, E, F = {}, G = !1; a.watchData = {}, this.init = function (h) { if (B = h, C = h.$options || m.ngModelOptions, u = angular.isDefined(c.closeOnDateSelection) ? a.$parent.$eval(c.closeOnDateSelection) : k.closeOnDateSelection, v = angular.isDefined(c.datepickerAppendToBody) ? a.$parent.$eval(c.datepickerAppendToBody) : k.appendToBody, w = angular.isDefined(c.onOpenFocus) ? a.$parent.$eval(c.onOpenFocus) : k.onOpenFocus, x = angular.isDefined(c.datepickerPopupTemplateUrl) ? c.datepickerPopupTemplateUrl : k.datepickerPopupTemplateUrl, y = angular.isDefined(c.datepickerTemplateUrl) ? c.datepickerTemplateUrl : k.datepickerTemplateUrl, E = angular.isDefined(c.altInputFormats) ? a.$parent.$eval(c.altInputFormats) : k.altInputFormats, a.showButtonBar = angular.isDefined(c.showButtonBar) ? a.$parent.$eval(c.showButtonBar) : k.showButtonBar, k.html5Types[c.type] ? (t = k.html5Types[c.type], G = !0) : (t = c.uibDatepickerPopup || k.datepickerPopup, c.$observe("uibDatepickerPopup", function (a, b) { var c = a || k.datepickerPopup; if (c !== t && (t = c, B.$modelValue = null, !t)) throw new Error("uibDatepickerPopup must have a date format specified.") })), !t) throw new Error("uibDatepickerPopup must have a date format specified."); if (G && c.uibDatepickerPopup) throw new Error("HTML5 date input types do not support custom formats."); if (z = angular.element("<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>"), a.ngModelOptions = angular.copy(C), a.ngModelOptions.timezone = null, z.attr({ "ng-model": "date", "ng-model-options": "ngModelOptions", "ng-change": "dateSelection(date)", "template-url": x }), A = angular.element(z.children()[0]), A.attr("template-url", y), G && "month" === c.type && (A.attr("datepicker-mode", '"month"'), A.attr("min-mode", "month")), c.datepickerOptions) { var l = a.$parent.$eval(c.datepickerOptions); l && l.initDate && (a.initDate = j.fromTimezone(l.initDate, C.timezone), A.attr("init-date", "initDate"), delete l.initDate), angular.forEach(l, function (a, b) { A.attr(n(b), a) }) } angular.forEach(["minMode", "maxMode"], function (b) { c[b] && (a.$parent.$watch(function () { return c[b] }, function (c) { a.watchData[b] = c }), A.attr(n(b), "watchData." + b)) }), angular.forEach(["datepickerMode", "shortcutPropagation"], function (b) { if (c[b]) { var d = e(c[b]), f = { get: function () { return d(a.$parent) } }; if (A.attr(n(b), "watchData." + b), "datepickerMode" === b) { var g = d.assign; f.set = function (b) { g(a.$parent, b) } } Object.defineProperty(a.watchData, b, f) } }), angular.forEach(["minDate", "maxDate", "initDate"], function (b) { if (c[b]) { var d = e(c[b]); a.$parent.$watch(d, function (c) { ("minDate" === b || "maxDate" === b) && (F[b] = angular.isDate(c) ? j.fromTimezone(new Date(c), C.timezone) : new Date(i(c, "medium"))), a.watchData[b] = F[b] || j.fromTimezone(new Date(c), C.timezone) }), A.attr(n(b), "watchData." + b) } }), c.dateDisabled && A.attr("date-disabled", "dateDisabled({ date: date, mode: mode })"), angular.forEach(["formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "showWeeks", "startingDay", "yearRows", "yearColumns"], function (a) { angular.isDefined(c[a]) && A.attr(n(a), c[a]) }), c.customClass && A.attr("custom-class", "customClass({ date: date, mode: mode })"), G ? B.$formatters.push(function (b) { return a.date = j.fromTimezone(b, C.timezone), b }) : (B.$$parserName = "date", B.$validators.date = q, B.$parsers.unshift(p), B.$formatters.push(function (b) { return B.$isEmpty(b) ? (a.date = b, b) : (a.date = j.fromTimezone(b, C.timezone), i(a.date, t)) })), B.$viewChangeListeners.push(function () { a.date = o(B.$viewValue) }), b.bind("keydown", s), D = d(z)(a), z.remove(), v ? f.find("body").append(D) : b.after(D), a.$on("$destroy", function () { a.isOpen === !0 && (g.$$phase || a.$apply(function () { a.isOpen = !1 })), D.remove(), b.unbind("keydown", s), f.unbind("click", r) }) }, a.getText = function (b) { return a[b + "Text"] || k[b + "Text"] }, a.isDisabled = function (b) { return "today" === b && (b = new Date), a.watchData.minDate && a.compare(b, F.minDate) < 0 || a.watchData.maxDate && a.compare(b, F.maxDate) > 0 }, a.compare = function (a, b) { return new Date(a.getFullYear(), a.getMonth(), a.getDate()) - new Date(b.getFullYear(), b.getMonth(), b.getDate()) }, a.dateSelection = function (c) { angular.isDefined(c) && (a.date = c); var d = a.date ? i(a.date, t) : null; b.val(d), B.$setViewValue(d), u && (a.isOpen = !1, b[0].focus()) }, a.keydown = function (c) { 27 === c.which && (c.stopPropagation(), a.isOpen = !1, b[0].focus()) }, a.select = function (b) { if ("today" === b) { var c = new Date; angular.isDate(a.date) ? (b = new Date(a.date), b.setFullYear(c.getFullYear(), c.getMonth(), c.getDate())) : b = new Date(c.setHours(0, 0, 0, 0)) } a.dateSelection(b) }, a.close = function () { a.isOpen = !1, b[0].focus() }, a.disabled = angular.isDefined(c.disabled) || !1, c.ngDisabled && a.$parent.$watch(e(c.ngDisabled), function (b) { a.disabled = b }), a.$watch("isOpen", function (c) { c ? a.disabled ? a.isOpen = !1 : (a.position = v ? h.offset(b) : h.position(b), a.position.top = a.position.top + b.prop("offsetHeight"), l(function () { w && a.$broadcast("uib:datepicker.focus"), f.bind("click", r) }, 0, !1)) : f.unbind("click", r) }) }]).directive("uibDatepickerPopup", function () { return { require: ["ngModel", "uibDatepickerPopup"], controller: "UibDatepickerPopupController", scope: { isOpen: "=?", currentText: "@", clearText: "@", closeText: "@", dateDisabled: "&", customClass: "&" }, link: function (a, b, c, d) { var e = d[0], f = d[1]; f.init(e) } } }).directive("uibDatepickerPopupWrap", function () { return { replace: !0, transclude: !0, templateUrl: function (a, b) { return b.templateUrl || "template/datepicker/popup.html" } } }), angular.module("ui.bootstrap.debounce", []).factory("$$debounce", ["$timeout", function (a) { return function (b, c) { var d; return function () { var e = this, f = Array.prototype.slice.call(arguments); d && a.cancel(d), d = a(function () { b.apply(e, f) }, c) } } }]), angular.module("ui.bootstrap.dropdown", ["ui.bootstrap.position"]).constant("uibDropdownConfig", { appendToOpenClass: "uib-dropdown-open", openClass: "open" }).service("uibDropdownService", ["$document", "$rootScope", function (a, b) { var c = null; this.open = function (b) { c || (a.on("click", d), a.on("keydown", e)), c && c !== b && (c.isOpen = !1), c = b }, this.close = function (b) { c === b && (c = null, a.off("click", d), a.off("keydown", e)) }; var d = function (a) { if (c && !(a && "disabled" === c.getAutoClose() || a && 3 === a.which)) { var d = c.getToggleElement(); if (!(a && d && d[0].contains(a.target))) { var e = c.getDropdownElement(); a && "outsideClick" === c.getAutoClose() && e && e[0].contains(a.target) || (c.isOpen = !1, b.$$phase || c.$apply()) } } }, e = function (a) { 27 === a.which ? (c.focusToggleElement(), d()) : c.isKeynavEnabled() && -1 !== [38, 40].indexOf(a.which) && c.isOpen && (a.preventDefault(), a.stopPropagation(), c.focusDropdownEntry(a.which)) } }]).controller("UibDropdownController", ["$scope", "$element", "$attrs", "$parse", "uibDropdownConfig", "uibDropdownService", "$animate", "$uibPosition", "$document", "$compile", "$templateRequest", function (a, b, c, d, e, f, g, h, i, j, k) { var l, m, n = this, o = a.$new(), p = e.appendToOpenClass, q = e.openClass, r = angular.noop, s = c.onToggle ? d(c.onToggle) : angular.noop, t = !1, u = null, v = !1, w = i.find("body"); b.addClass("dropdown"), this.init = function () { if (c.isOpen && (m = d(c.isOpen), r = m.assign, a.$watch(m, function (a) { o.isOpen = !!a })), angular.isDefined(c.dropdownAppendTo)) { var e = d(c.dropdownAppendTo)(o); e && (u = angular.element(e)) } t = angular.isDefined(c.dropdownAppendToBody), v = angular.isDefined(c.keyboardNav), t && !u && (u = w), u && n.dropdownMenu && (u.append(n.dropdownMenu), b.on("$destroy", function () { n.dropdownMenu.remove() })) }, this.toggle = function (a) { return o.isOpen = arguments.length ? !!a : !o.isOpen }, this.isOpen = function () { return o.isOpen }, o.getToggleElement = function () { return n.toggleElement }, o.getAutoClose = function () { return c.autoClose || "always" }, o.getElement = function () { return b }, o.isKeynavEnabled = function () { return v }, o.focusDropdownEntry = function (a) { var c = n.dropdownMenu ? angular.element(n.dropdownMenu).find("a") : b.find("ul").eq(0).find("a"); switch (a) { case 40: angular.isNumber(n.selectedOption) ? n.selectedOption = n.selectedOption === c.length - 1 ? n.selectedOption : n.selectedOption + 1 : n.selectedOption = 0; break; case 38: angular.isNumber(n.selectedOption) ? n.selectedOption = 0 === n.selectedOption ? 0 : n.selectedOption - 1 : n.selectedOption = c.length - 1 } c[n.selectedOption].focus() }, o.getDropdownElement = function () { return n.dropdownMenu }, o.focusToggleElement = function () { n.toggleElement && n.toggleElement[0].focus() }, o.$watch("isOpen", function (c, d) { if (u && n.dropdownMenu) { var e, i, m = h.positionElements(b, n.dropdownMenu, "bottom-left", !0); if (e = { top: m.top + "px", display: c ? "block" : "none" }, i = n.dropdownMenu.hasClass("dropdown-menu-right"), i ? (e.left = "auto", e.right = window.innerWidth - (m.left + b.prop("offsetWidth")) + "px") : (e.left = m.left + "px", e.right = "auto"), !t) { var v = h.offset(u); e.top = m.top - v.top + "px", i ? e.right = window.innerWidth - (m.left - v.left + b.prop("offsetWidth")) + "px" : e.left = m.left - v.left + "px" } n.dropdownMenu.css(e) } var w = u ? u : b; if (g[c ? "addClass" : "removeClass"](w, u ? p : q).then(function () { angular.isDefined(c) && c !== d && s(a, { open: !!c }) }), c) n.dropdownMenuTemplateUrl && k(n.dropdownMenuTemplateUrl).then(function (a) { l = o.$new(), j(a.trim())(l, function (a) { var b = a; n.dropdownMenu.replaceWith(b), n.dropdownMenu = b }) }), o.focusToggleElement(), f.open(o); else { if (n.dropdownMenuTemplateUrl) { l && l.$destroy(); var x = angular.element('<ul class="dropdown-menu"></ul>'); n.dropdownMenu.replaceWith(x), n.dropdownMenu = x } f.close(o), n.selectedOption = null } angular.isFunction(r) && r(a, c) }), a.$on("$locationChangeSuccess", function () { "disabled" !== o.getAutoClose() && (o.isOpen = !1) }) }]).directive("uibDropdown", function () { return { controller: "UibDropdownController", link: function (a, b, c, d) { d.init() } } }).directive("uibDropdownMenu", function () { return { restrict: "A", require: "?^uibDropdown", link: function (a, b, c, d) { if (d && !angular.isDefined(c.dropdownNested)) { b.addClass("dropdown-menu"); var e = c.templateUrl; e && (d.dropdownMenuTemplateUrl = e), d.dropdownMenu || (d.dropdownMenu = b) } } } }).directive("uibDropdownToggle", function () { return { require: "?^uibDropdown", link: function (a, b, c, d) { if (d) { b.addClass("dropdown-toggle"), d.toggleElement = b; var e = function (e) { e.preventDefault(), b.hasClass("disabled") || c.disabled || a.$apply(function () { d.toggle() }) }; b.bind("click", e), b.attr({ "aria-haspopup": !0, "aria-expanded": !1 }), a.$watch(d.isOpen, function (a) { b.attr("aria-expanded", !!a) }), a.$on("$destroy", function () { b.unbind("click", e) }) } } } }), angular.module("ui.bootstrap.stackedMap", []).factory("$$stackedMap", function () { return { createNew: function () { var a = []; return { add: function (b, c) { a.push({ key: b, value: c }) }, get: function (b) { for (var c = 0; c < a.length; c++) if (b === a[c].key) return a[c] }, keys: function () { for (var b = [], c = 0; c < a.length; c++) b.push(a[c].key); return b }, top: function () { return a[a.length - 1] }, remove: function (b) { for (var c = -1, d = 0; d < a.length; d++) if (b === a[d].key) { c = d; break } return a.splice(c, 1)[0] }, removeTop: function () { return a.splice(a.length - 1, 1)[0] }, length: function () { return a.length } } } } }), angular.module("ui.bootstrap.modal", ["ui.bootstrap.stackedMap"]).factory("$$multiMap", function () { return { createNew: function () { var a = {}; return { entries: function () { return Object.keys(a).map(function (b) { return { key: b, value: a[b] } }) }, get: function (b) { return a[b] }, hasKey: function (b) { return !!a[b] }, keys: function () { return Object.keys(a) }, put: function (b, c) { a[b] || (a[b] = []), a[b].push(c) }, remove: function (b, c) { var d = a[b]; if (d) { var e = d.indexOf(c); -1 !== e && d.splice(e, 1), d.length || delete a[b] } } } } } }).provider("$uibResolve", function () { var a = this; this.resolver = null, this.setResolver = function (a) { this.resolver = a }, this.$get = ["$injector", "$q", function (b, c) { var d = a.resolver ? b.get(a.resolver) : null; return { resolve: function (a, e, f, g) { if (d) return d.resolve(a, e, f, g); var h = []; return angular.forEach(a, function (a) { angular.isFunction(a) || angular.isArray(a) ? h.push(c.resolve(b.invoke(a))) : angular.isString(a) ? h.push(c.resolve(b.get(a))) : h.push(c.resolve(a)) }), c.all(h).then(function (b) { var c = {}, d = 0; return angular.forEach(a, function (a, e) { c[e] = b[d++] }), c }) } } }] }).directive("uibModalBackdrop", ["$animateCss", "$injector", "$uibModalStack", function (a, b, c) { function d(b, d, e) { e.modalInClass && (a(d, { addClass: e.modalInClass }).start(), b.$on(c.NOW_CLOSING_EVENT, function (c, f) { var g = f(); b.modalOptions.animation ? a(d, { removeClass: e.modalInClass }).start().then(g) : g() })) } return { replace: !0, templateUrl: "uib/template/modal/backdrop.html", compile: function (a, b) { return a.addClass(b.backdropClass), d } } }]).directive("uibModalWindow", ["$uibModalStack", "$q", "$animate", "$animateCss", "$document", function (a, b, c, d, e) { return { scope: { index: "@" }, replace: !0, transclude: !0, templateUrl: function (a, b) { return b.templateUrl || "uib/template/modal/window.html" }, link: function (f, g, h) { g.addClass(h.windowClass || ""), g.addClass(h.windowTopClass || ""), f.size = h.size, f.close = function (b) { var c = a.getTop(); c && c.value.backdrop && "static" !== c.value.backdrop && b.target === b.currentTarget && (b.preventDefault(), b.stopPropagation(), a.dismiss(c.key, "backdrop click")) }, g.on("click", f.close), f.$isRendered = !0; var i = b.defer(); h.$observe("modalRender", function (a) { "true" === a && i.resolve() }), i.promise.then(function () { var i = null; h.modalInClass && (i = d(g, { addClass: h.modalInClass }).start(), f.$on(a.NOW_CLOSING_EVENT, function (a, b) { var e = b(); d ? d(g, { removeClass: h.modalInClass }).start().then(e) : c.removeClass(g, h.modalInClass).then(e) })), b.when(i).then(function () { if (!e[0].activeElement || !g[0].contains(e[0].activeElement)) { var a = g[0].querySelector("[autofocus]"); a ? a.focus() : g[0].focus() } }); var j = a.getTop(); j && a.modalRendered(j.key) }) } } }]).directive("uibModalAnimationClass", function () { return { compile: function (a, b) { b.modalAnimation && a.addClass(b.uibModalAnimationClass) } } }).directive("uibModalTransclude", function () { return { link: function (a, b, c, d, e) { e(a.$parent, function (a) { b.empty(), b.append(a) }) } } }).factory("$uibModalStack", ["$animate", "$animateCss", "$document", "$compile", "$rootScope", "$q", "$$multiMap", "$$stackedMap", function (a, b, c, d, e, f, g, h) { function i() { for (var a = -1, b = t.keys(), c = 0; c < b.length; c++) t.get(b[c]).value.backdrop && (a = c); return a } function j(a, b) { var c = t.get(a).value, d = c.appendTo; t.remove(a), m(c.modalDomEl, c.modalScope, function () { var b = c.openedClass || s; u.remove(b, a), d.toggleClass(b, u.hasKey(b)), k(!0) }), l(), b && b.focus ? b.focus() : d.focus && d.focus() } function k(a) { var b; t.length() > 0 && (b = t.top().value, b.modalDomEl.toggleClass(b.windowTopClass || "", a)) } function l() { if (p && -1 === i()) { var a = q; m(p, q, function () { a = null }), p = void 0, q = void 0 } } function m(a, c, d, e) { function g() { g.done || (g.done = !0, b(a, { event: "leave" }).start().then(function () { a.remove(), e && e.resolve() }), c.$destroy(), d && d()) } var h, i = null, j = function () { return h || (h = f.defer(), i = h.promise), function () { h.resolve() } }; return c.$broadcast(v.NOW_CLOSING_EVENT, j), f.when(i).then(g) } function n(a) { if (a.isDefaultPrevented()) return a; var b = t.top(); if (b) switch (a.which) { case 27: b.value.keyboard && (a.preventDefault(), e.$apply(function () { v.dismiss(b.key, "escape key press") })); break; case 9: v.loadFocusElementList(b); var c = !1; a.shiftKey ? v.isFocusInFirstItem(a) && (c = v.focusLastFocusableElement()) : v.isFocusInLastItem(a) && (c = v.focusFirstFocusableElement()), c && (a.preventDefault(), a.stopPropagation()) } } function o(a, b, c) { return !a.value.modalScope.$broadcast("modal.closing", b, c).defaultPrevented } var p, q, r, s = "modal-open", t = h.createNew(), u = g.createNew(), v = { NOW_CLOSING_EVENT: "modal.stack.now-closing" }, w = 0, x = "a[href], area[href], input:not([disabled]), button:not([disabled]),select:not([disabled]), textarea:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable=true]"; return e.$watch(i, function (a) { q && (q.index = a) }), c.on("keydown", n), e.$on("$destroy", function () { c.off("keydown", n) }), v.open = function (b, f) { var g = c[0].activeElement, h = f.openedClass || s; k(!1), t.add(b, { deferred: f.deferred, renderDeferred: f.renderDeferred, closedDeferred: f.closedDeferred, modalScope: f.scope, backdrop: f.backdrop, keyboard: f.keyboard, openedClass: f.openedClass, windowTopClass: f.windowTopClass, animation: f.animation, appendTo: f.appendTo }), u.put(h, b); var j = f.appendTo, l = i(); if (!j.length) throw new Error("appendTo element not found. Make sure that the element passed is in DOM."); l >= 0 && !p && (q = e.$new(!0), q.modalOptions = f, q.index = l, p = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'), p.attr("backdrop-class", f.backdropClass), f.animation && p.attr("modal-animation", "true"), d(p)(q), a.enter(p, j)); var m = angular.element('<div uib-modal-window="modal-window"></div>'); m.attr({ "template-url": f.windowTemplateUrl, "window-class": f.windowClass, "window-top-class": f.windowTopClass, size: f.size, index: t.length() - 1, animate: "animate" }).html(f.content), f.animation && m.attr("modal-animation", "true"), a.enter(m, j).then(function () { d(m)(f.scope), a.addClass(j, h) }), t.top().value.modalDomEl = m, t.top().value.modalOpener = g, v.clearFocusListCache() }, v.close = function (a, b) { var c = t.get(a); return c && o(c, b, !0) ? (c.value.modalScope.$$uibDestructionScheduled = !0, c.value.deferred.resolve(b), j(a, c.value.modalOpener), !0) : !c }, v.dismiss = function (a, b) { var c = t.get(a); return c && o(c, b, !1) ? (c.value.modalScope.$$uibDestructionScheduled = !0, c.value.deferred.reject(b), j(a, c.value.modalOpener), !0) : !c }, v.dismissAll = function (a) { for (var b = this.getTop() ; b && this.dismiss(b.key, a) ;) b = this.getTop() }, v.getTop = function () { return t.top() }, v.modalRendered = function (a) { var b = t.get(a); b && b.value.renderDeferred.resolve() }, v.focusFirstFocusableElement = function () { return r.length > 0 ? (r[0].focus(), !0) : !1 }, v.focusLastFocusableElement = function () { return r.length > 0 ? (r[r.length - 1].focus(), !0) : !1 }, v.isFocusInFirstItem = function (a) { return r.length > 0 ? (a.target || a.srcElement) === r[0] : !1 }, v.isFocusInLastItem = function (a) { return r.length > 0 ? (a.target || a.srcElement) === r[r.length - 1] : !1 }, v.clearFocusListCache = function () { r = [], w = 0 }, v.loadFocusElementList = function (a) { if ((void 0 === r || !r.length) && a) { var b = a.value.modalDomEl; b && b.length && (r = b[0].querySelectorAll(x)) } }, v }]).provider("$uibModal", function () { var a = { options: { animation: !0, backdrop: !0, keyboard: !0 }, $get: ["$rootScope", "$q", "$document", "$templateRequest", "$controller", "$uibResolve", "$uibModalStack", function (b, c, d, e, f, g, h) { function i(a) { return a.template ? c.when(a.template) : e(angular.isFunction(a.templateUrl) ? a.templateUrl() : a.templateUrl) } var j = {}, k = null; return j.getPromiseChain = function () { return k }, j.open = function (e) { function j() { return r } var l = c.defer(), m = c.defer(), n = c.defer(), o = c.defer(), p = { result: l.promise, opened: m.promise, closed: n.promise, rendered: o.promise, close: function (a) { return h.close(p, a) }, dismiss: function (a) { return h.dismiss(p, a) } }; if (e = angular.extend({}, a.options, e), e.resolve = e.resolve || {}, e.appendTo = e.appendTo || d.find("body").eq(0), !e.template && !e.templateUrl) throw new Error("One of template or templateUrl options is required."); var q, r = c.all([i(e), g.resolve(e.resolve, {}, null, null)]); return q = k = c.all([k]).then(j, j).then(function (a) { var c = e.scope || b, d = c.$new(); d.$close = p.close, d.$dismiss = p.dismiss, d.$on("$destroy", function () { d.$$uibDestructionScheduled || d.$dismiss("$uibUnscheduledDestruction") }); var g, i = {}; e.controller && (i.$scope = d, i.$uibModalInstance = p, angular.forEach(a[1], function (a, b) { i[b] = a }), g = f(e.controller, i), e.controllerAs && (e.bindToController && (g.$close = d.$close, g.$dismiss = d.$dismiss, angular.extend(g, c)), d[e.controllerAs] = g)), h.open(p, { scope: d, deferred: l, renderDeferred: o, closedDeferred: n, content: a[0], animation: e.animation, backdrop: e.backdrop, keyboard: e.keyboard, backdropClass: e.backdropClass, windowTopClass: e.windowTopClass, windowClass: e.windowClass, windowTemplateUrl: e.windowTemplateUrl, size: e.size, openedClass: e.openedClass, appendTo: e.appendTo }), m.resolve(!0) }, function (a) { m.reject(a), l.reject(a) })["finally"](function () { k === q && (k = null) }), p }, j }] }; return a }), angular.module("ui.bootstrap.paging", []).factory("uibPaging", ["$parse", function (a) { return { create: function (b, c, d) { b.setNumPages = d.numPages ? a(d.numPages).assign : angular.noop, b.ngModelCtrl = { $setViewValue: angular.noop }, b.init = function (e, f) { b.ngModelCtrl = e, b.config = f, e.$render = function () { b.render() }, d.itemsPerPage ? c.$parent.$watch(a(d.itemsPerPage), function (a) { b.itemsPerPage = parseInt(a, 10), c.totalPages = b.calculateTotalPages(), b.updatePage() }) : b.itemsPerPage = f.itemsPerPage, c.$watch("totalItems", function (a, d) { (angular.isDefined(a) || a !== d) && (c.totalPages = b.calculateTotalPages(), b.updatePage()) }) }, b.calculateTotalPages = function () { var a = b.itemsPerPage < 1 ? 1 : Math.ceil(c.totalItems / b.itemsPerPage); return Math.max(a || 0, 1) }, b.render = function () { c.page = parseInt(b.ngModelCtrl.$viewValue, 10) || 1 }, c.selectPage = function (a, d) { d && d.preventDefault(); var e = !c.ngDisabled || !d; e && c.page !== a && a > 0 && a <= c.totalPages && (d && d.target && d.target.blur(), b.ngModelCtrl.$setViewValue(a), b.ngModelCtrl.$render()) }, c.getText = function (a) { return c[a + "Text"] || b.config[a + "Text"] }, c.noPrevious = function () { return 1 === c.page }, c.noNext = function () { return c.page === c.totalPages }, b.updatePage = function () { b.setNumPages(c.$parent, c.totalPages), c.page > c.totalPages ? c.selectPage(c.totalPages) : b.ngModelCtrl.$render() } } } }]), angular.module("ui.bootstrap.pager", ["ui.bootstrap.paging"]).controller("UibPagerController", ["$scope", "$attrs", "uibPaging", "uibPagerConfig", function (a, b, c, d) { a.align = angular.isDefined(b.align) ? a.$parent.$eval(b.align) : d.align, c.create(this, a, b) }]).constant("uibPagerConfig", { itemsPerPage: 10, previousText: "« Previous", nextText: "Next »", align: !0 }).directive("uibPager", ["uibPagerConfig", function (a) { return { scope: { totalItems: "=", previousText: "@", nextText: "@", ngDisabled: "=" }, require: ["uibPager", "?ngModel"], controller: "UibPagerController", controllerAs: "pager", templateUrl: function (a, b) { return b.templateUrl || "uib/template/pager/pager.html" }, replace: !0, link: function (b, c, d, e) { var f = e[0], g = e[1]; g && f.init(g, a) } } }]), angular.module("ui.bootstrap.pagination", ["ui.bootstrap.paging"]).controller("UibPaginationController", ["$scope", "$attrs", "$parse", "uibPaging", "uibPaginationConfig", function (a, b, c, d, e) { function f(a, b, c) { return { number: a, text: b, active: c } } function g(a, b) { var c = [], d = 1, e = b, g = angular.isDefined(i) && b > i; g && (j ? (d = Math.max(a - Math.floor(i / 2), 1), e = d + i - 1, e > b && (e = b, d = e - i + 1)) : (d = (Math.ceil(a / i) - 1) * i + 1, e = Math.min(d + i - 1, b))); for (var h = d; e >= h; h++) { var m = f(h, h, h === a); c.push(m) } if (g && i > 0 && (!j || k || l)) { if (d > 1) { if (!l || d > 3) { var n = f(d - 1, "...", !1); c.unshift(n) } if (l) { if (3 === d) { var o = f(2, "2", !1); c.unshift(o) } var p = f(1, "1", !1); c.unshift(p) } } if (b > e) { if (!l || b - 2 > e) { var q = f(e + 1, "...", !1); c.push(q) } if (l) { if (e === b - 2) { var r = f(b - 1, b - 1, !1); c.push(r) } var s = f(b, b, !1); c.push(s) } } } return c } var h = this, i = angular.isDefined(b.maxSize) ? a.$parent.$eval(b.maxSize) : e.maxSize, j = angular.isDefined(b.rotate) ? a.$parent.$eval(b.rotate) : e.rotate, k = angular.isDefined(b.forceEllipses) ? a.$parent.$eval(b.forceEllipses) : e.forceEllipses, l = angular.isDefined(b.boundaryLinkNumbers) ? a.$parent.$eval(b.boundaryLinkNumbers) : e.boundaryLinkNumbers; a.boundaryLinks = angular.isDefined(b.boundaryLinks) ? a.$parent.$eval(b.boundaryLinks) : e.boundaryLinks, a.directionLinks = angular.isDefined(b.directionLinks) ? a.$parent.$eval(b.directionLinks) : e.directionLinks, d.create(this, a, b), b.maxSize && a.$parent.$watch(c(b.maxSize), function (a) { i = parseInt(a, 10), h.render() }); var m = this.render; this.render = function () { m(), a.page > 0 && a.page <= a.totalPages && (a.pages = g(a.page, a.totalPages)) } }]).constant("uibPaginationConfig", { itemsPerPage: 10, boundaryLinks: !1, boundaryLinkNumbers: !1, directionLinks: !0, firstText: "First", previousText: "Previous", nextText: "Next", lastText: "Last", rotate: !0, forceEllipses: !1 }).directive("uibPagination", ["$parse", "uibPaginationConfig", function (a, b) { return { scope: { totalItems: "=", firstText: "@", previousText: "@", nextText: "@", lastText: "@", ngDisabled: "=" }, require: ["uibPagination", "?ngModel"], controller: "UibPaginationController", controllerAs: "pagination", templateUrl: function (a, b) { return b.templateUrl || "uib/template/pagination/pagination.html" }, replace: !0, link: function (a, c, d, e) { var f = e[0], g = e[1]; g && f.init(g, b) } } }]), angular.module("ui.bootstrap.tooltip", ["ui.bootstrap.position", "ui.bootstrap.stackedMap"]).provider("$uibTooltip", function () { function a(a) { var b = /[A-Z]/g, c = "-"; return a.replace(b, function (a, b) { return (b ? c : "") + a.toLowerCase() }) } var b = { placement: "top", placementClassPrefix: "", animation: !0, popupDelay: 0, popupCloseDelay: 0, useContentExp: !1 }, c = { mouseenter: "mouseleave", click: "click", outsideClick: "outsideClick", focus: "blur", none: "" }, d = {}; this.options = function (a) { angular.extend(d, a) }, this.setTriggers = function (a) { angular.extend(c, a) }, this.$get = ["$window", "$compile", "$timeout", "$document", "$uibPosition", "$interpolate", "$rootScope", "$parse", "$$stackedMap", function (e, f, g, h, i, j, k, l, m) { function n(a) { if (27 === a.which) { var b = o.top(); b && (b.value.close(), o.removeTop(), b = null) } } var o = m.createNew(); return h.on("keypress", n), k.$on("$destroy", function () { h.off("keypress", n) }), function (e, k, m, n) { function p(a) { var b = (a || n.trigger || m).split(" "), d = b.map(function (a) { return c[a] || a }); return { show: b, hide: d } } n = angular.extend({}, b, d, n); var q = a(e), r = j.startSymbol(), s = j.endSymbol(), t = "<div " + q + '-popup title="' + r + "title" + s + '" ' + (n.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + r + "content" + s + '" ') + 'placement="' + r + "placement" + s + '" popup-class="' + r + "popupClass" + s + '" animation="animation" is-open="isOpen"origin-scope="origScope" style="visibility: hidden; display: block; top: -9999px; left: -9999px;"></div>'; return { compile: function (a, b) { var c = f(t); return function (a, b, d, f) { function j() { M.isOpen ? q() : m() } function m() { (!L || a.$eval(d[k + "Enable"])) && (u(), x(), M.popupDelay ? G || (G = g(r, M.popupDelay, !1)) : r()) } function q() { s(), M.popupCloseDelay ? H || (H = g(t, M.popupCloseDelay, !1)) : t() } function r() { return s(), u(), M.content ? (v(), void M.$evalAsync(function () { M.isOpen = !0, y(!0), R() })) : angular.noop } function s() { G && (g.cancel(G), G = null), I && (g.cancel(I), I = null) } function t() { M && M.$evalAsync(function () { M.isOpen = !1, y(!1), M.animation ? F || (F = g(w, 150, !1)) : w() }) } function u() { H && (g.cancel(H), H = null), F && (g.cancel(F), F = null) } function v() { D || (E = M.$new(), D = c(E, function (a) { J ? h.find("body").append(a) : b.after(a) }), z()) } function w() { s(), u(), A(), D && (D.remove(), D = null), E && (E.$destroy(), E = null) } function x() { M.title = d[k + "Title"], P ? M.content = P(a) : M.content = d[e], M.popupClass = d[k + "Class"], M.placement = angular.isDefined(d[k + "Placement"]) ? d[k + "Placement"] : n.placement; var b = parseInt(d[k + "PopupDelay"], 10), c = parseInt(d[k + "PopupCloseDelay"], 10); M.popupDelay = isNaN(b) ? n.popupDelay : b, M.popupCloseDelay = isNaN(c) ? n.popupCloseDelay : c } function y(b) { O && angular.isFunction(O.assign) && O.assign(a, b) } function z() { Q.length = 0, P ? (Q.push(a.$watch(P, function (a) { M.content = a, !a && M.isOpen && t() })), Q.push(E.$watch(function () { N || (N = !0, E.$$postDigest(function () { N = !1, M && M.isOpen && R() })) }))) : Q.push(d.$observe(e, function (a) { M.content = a, !a && M.isOpen ? t() : R() })), Q.push(d.$observe(k + "Title", function (a) { M.title = a, M.isOpen && R() })), Q.push(d.$observe(k + "Placement", function (a) { M.placement = a ? a : n.placement, M.isOpen && R() })) } function A() { Q.length && (angular.forEach(Q, function (a) { a() }), Q.length = 0) } function B(a) { M && M.isOpen && D && (b[0].contains(a.target) || D[0].contains(a.target) || q()) } function C() { var a = d[k + "Trigger"]; S(), K = p(a), "none" !== K.show && K.show.forEach(function (a, c) { "outsideClick" === a ? (b.on("click", j), h.on("click", B)) : a === K.hide[c] ? b.on(a, j) : a && (b.on(a, m), b.on(K.hide[c], q)), b.on("keypress", function (a) { 27 === a.which && q() }) }) } var D, E, F, G, H, I, J = angular.isDefined(n.appendToBody) ? n.appendToBody : !1, K = p(void 0), L = angular.isDefined(d[k + "Enable"]), M = a.$new(!0), N = !1, O = angular.isDefined(d[k + "IsOpen"]) ? l(d[k + "IsOpen"]) : !1, P = n.useContentExp ? l(d[e]) : !1, Q = [], R = function () { D && D.html() && (I || (I = g(function () { D.css({ top: 0, left: 0 }); var a = i.positionElements(b, D, M.placement, J); D.css({ top: a.top + "px", left: a.left + "px", visibility: "visible" }), n.placementClassPrefix && D.removeClass("top bottom left right"), D.removeClass(n.placementClassPrefix + "top " + n.placementClassPrefix + "top-left " + n.placementClassPrefix + "top-right " + n.placementClassPrefix + "bottom " + n.placementClassPrefix + "bottom-left " + n.placementClassPrefix + "bottom-right " + n.placementClassPrefix + "left " + n.placementClassPrefix + "left-top " + n.placementClassPrefix + "left-bottom " + n.placementClassPrefix + "right " + n.placementClassPrefix + "right-top " + n.placementClassPrefix + "right-bottom"); var c = a.placement.split("-"); D.addClass(c[0], n.placementClassPrefix + a.placement), i.positionArrow(D, a.placement), I = null }, 0, !1))) }; M.origScope = a, M.isOpen = !1, o.add(M, { close: t }), M.contentExp = function () { return M.content }, d.$observe("disabled", function (a) { a && s(), a && M.isOpen && t() }), O && a.$watch(O, function (a) { M && !a === M.isOpen && j() }); var S = function () { K.show.forEach(function (a) { "outsideClick" === a ? b.off("click", j) : (b.off(a, m), b.off(a, j)) }), K.hide.forEach(function (a) { "outsideClick" === a ? h.off("click", B) : b.off(a, q) }) }; C(); var T = a.$eval(d[k + "Animation"]); M.animation = angular.isDefined(T) ? !!T : n.animation; var U, V = k + "AppendToBody"; U = V in d && void 0 === d[V] ? !0 : a.$eval(d[V]), J = angular.isDefined(U) ? U : J, J && a.$on("$locationChangeSuccess", function () { M.isOpen && t() }), a.$on("$destroy", function () { S(), w(), o.remove(M), M = null }) } } } } }] }).directive("uibTooltipTemplateTransclude", ["$animate", "$sce", "$compile", "$templateRequest", function (a, b, c, d) { return { link: function (e, f, g) { var h, i, j, k = e.$eval(g.tooltipTemplateTranscludeScope), l = 0, m = function () { i && (i.remove(), i = null), h && (h.$destroy(), h = null), j && (a.leave(j).then(function () { i = null }), i = j, j = null) }; e.$watch(b.parseAsResourceUrl(g.uibTooltipTemplateTransclude), function (b) { var g = ++l; b ? (d(b, !0).then(function (d) { if (g === l) { var e = k.$new(), i = d, n = c(i)(e, function (b) { m(), a.enter(b, f) }); h = e, j = n, h.$emit("$includeContentLoaded", b) } }, function () { g === l && (m(), e.$emit("$includeContentError", b)) }), e.$emit("$includeContentRequested", b)) : m() }), e.$on("$destroy", m) } } }]).directive("uibTooltipClasses", ["$uibPosition", function (a) { return { restrict: "A", link: function (b, c, d) { if (b.placement) { var e = a.parsePlacement(b.placement); c.addClass(e[0]) } else c.addClass("top"); b.popupClass && c.addClass(b.popupClass), b.animation() && c.addClass(d.tooltipAnimationClass) } } }]).directive("uibTooltipPopup", function () { return { replace: !0, scope: { content: "@", placement: "@", popupClass: "@", animation: "&", isOpen: "&" }, templateUrl: "uib/template/tooltip/tooltip-popup.html" } }).directive("uibTooltip", ["$uibTooltip", function (a) { return a("uibTooltip", "tooltip", "mouseenter") }]).directive("uibTooltipTemplatePopup", function () { return { replace: !0, scope: { contentExp: "&", placement: "@", popupClass: "@", animation: "&", isOpen: "&", originScope: "&" }, templateUrl: "uib/template/tooltip/tooltip-template-popup.html" } }).directive("uibTooltipTemplate", ["$uibTooltip", function (a) { return a("uibTooltipTemplate", "tooltip", "mouseenter", { useContentExp: !0 }) }]).directive("uibTooltipHtmlPopup", function () {
//    return {
//        replace: !0, scope: {
//            contentExp: "&",
//            placement: "@", popupClass: "@", animation: "&", isOpen: "&"
//        }, templateUrl: "uib/template/tooltip/tooltip-html-popup.html"
//    }
//}).directive("uibTooltipHtml", ["$uibTooltip", function (a) { return a("uibTooltipHtml", "tooltip", "mouseenter", { useContentExp: !0 }) }]), angular.module("ui.bootstrap.popover", ["ui.bootstrap.tooltip"]).directive("uibPopoverTemplatePopup", function () { return { replace: !0, scope: { title: "@", contentExp: "&", placement: "@", popupClass: "@", animation: "&", isOpen: "&", originScope: "&" }, templateUrl: "uib/template/popover/popover-template.html" } }).directive("uibPopoverTemplate", ["$uibTooltip", function (a) { return a("uibPopoverTemplate", "popover", "click", { useContentExp: !0 }) }]).directive("uibPopoverHtmlPopup", function () { return { replace: !0, scope: { contentExp: "&", title: "@", placement: "@", popupClass: "@", animation: "&", isOpen: "&" }, templateUrl: "uib/template/popover/popover-html.html" } }).directive("uibPopoverHtml", ["$uibTooltip", function (a) { return a("uibPopoverHtml", "popover", "click", { useContentExp: !0 }) }]).directive("uibPopoverPopup", function () { return { replace: !0, scope: { title: "@", content: "@", placement: "@", popupClass: "@", animation: "&", isOpen: "&" }, templateUrl: "uib/template/popover/popover.html" } }).directive("uibPopover", ["$uibTooltip", function (a) { return a("uibPopover", "popover", "click") }]), angular.module("ui.bootstrap.progressbar", []).constant("uibProgressConfig", { animate: !0, max: 100 }).controller("UibProgressController", ["$scope", "$attrs", "uibProgressConfig", function (a, b, c) { var d = this, e = angular.isDefined(b.animate) ? a.$parent.$eval(b.animate) : c.animate; this.bars = [], a.max = angular.isDefined(a.max) ? a.max : c.max, this.addBar = function (b, c, f) { e || c.css({ transition: "none" }), this.bars.push(b), b.max = a.max, b.title = f && angular.isDefined(f.title) ? f.title : "progressbar", b.$watch("value", function (a) { b.recalculatePercentage() }), b.recalculatePercentage = function () { var a = d.bars.reduce(function (a, b) { return b.percent = +(100 * b.value / b.max).toFixed(2), a + b.percent }, 0); a > 100 && (b.percent -= a - 100) }, b.$on("$destroy", function () { c = null, d.removeBar(b) }) }, this.removeBar = function (a) { this.bars.splice(this.bars.indexOf(a), 1), this.bars.forEach(function (a) { a.recalculatePercentage() }) }, a.$watch("max", function (b) { d.bars.forEach(function (b) { b.max = a.max, b.recalculatePercentage() }) }) }]).directive("uibProgress", function () { return { replace: !0, transclude: !0, controller: "UibProgressController", require: "uibProgress", scope: { max: "=?" }, templateUrl: "uib/template/progressbar/progress.html" } }).directive("uibBar", function () { return { replace: !0, transclude: !0, require: "^uibProgress", scope: { value: "=", type: "@" }, templateUrl: "uib/template/progressbar/bar.html", link: function (a, b, c, d) { d.addBar(a, b, c) } } }).directive("uibProgressbar", function () { return { replace: !0, transclude: !0, controller: "UibProgressController", scope: { value: "=", max: "=?", type: "@" }, templateUrl: "uib/template/progressbar/progressbar.html", link: function (a, b, c, d) { d.addBar(a, angular.element(b.children()[0]), { title: c.title }) } } }), angular.module("ui.bootstrap.rating", []).constant("uibRatingConfig", { max: 5, stateOn: null, stateOff: null, titles: ["one", "two", "three", "four", "five"] }).controller("UibRatingController", ["$scope", "$attrs", "uibRatingConfig", function (a, b, c) { var d = { $setViewValue: angular.noop }; this.init = function (e) { d = e, d.$render = this.render, d.$formatters.push(function (a) { return angular.isNumber(a) && a << 0 !== a && (a = Math.round(a)), a }), this.stateOn = angular.isDefined(b.stateOn) ? a.$parent.$eval(b.stateOn) : c.stateOn, this.stateOff = angular.isDefined(b.stateOff) ? a.$parent.$eval(b.stateOff) : c.stateOff; var f = angular.isDefined(b.titles) ? a.$parent.$eval(b.titles) : c.titles; this.titles = angular.isArray(f) && f.length > 0 ? f : c.titles; var g = angular.isDefined(b.ratingStates) ? a.$parent.$eval(b.ratingStates) : new Array(angular.isDefined(b.max) ? a.$parent.$eval(b.max) : c.max); a.range = this.buildTemplateObjects(g) }, this.buildTemplateObjects = function (a) { for (var b = 0, c = a.length; c > b; b++) a[b] = angular.extend({ index: b }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(b) }, a[b]); return a }, this.getTitle = function (a) { return a >= this.titles.length ? a + 1 : this.titles[a] }, a.rate = function (b) { !a.readonly && b >= 0 && b <= a.range.length && (d.$setViewValue(d.$viewValue === b ? 0 : b), d.$render()) }, a.enter = function (b) { a.readonly || (a.value = b), a.onHover({ value: b }) }, a.reset = function () { a.value = d.$viewValue, a.onLeave() }, a.onKeydown = function (b) { /(37|38|39|40)/.test(b.which) && (b.preventDefault(), b.stopPropagation(), a.rate(a.value + (38 === b.which || 39 === b.which ? 1 : -1))) }, this.render = function () { a.value = d.$viewValue } }]).directive("uibRating", function () { return { require: ["uibRating", "ngModel"], scope: { readonly: "=?", onHover: "&", onLeave: "&" }, controller: "UibRatingController", templateUrl: "uib/template/rating/rating.html", replace: !0, link: function (a, b, c, d) { var e = d[0], f = d[1]; e.init(f) } } }), angular.module("ui.bootstrap.tabs", []).controller("UibTabsetController", ["$scope", function (a) { var b = this, c = b.tabs = a.tabs = []; b.select = function (a) { angular.forEach(c, function (b) { b.active && b !== a && (b.active = !1, b.onDeselect(), a.selectCalled = !1) }), a.active = !0, a.selectCalled || (a.onSelect(), a.selectCalled = !0) }, b.addTab = function (a) { c.push(a), 1 === c.length && a.active !== !1 ? a.active = !0 : a.active ? b.select(a) : a.active = !1 }, b.removeTab = function (a) { var e = c.indexOf(a); if (a.active && c.length > 1 && !d) { var f = e === c.length - 1 ? e - 1 : e + 1; b.select(c[f]) } c.splice(e, 1) }; var d; a.$on("$destroy", function () { d = !0 }) }]).directive("uibTabset", function () { return { transclude: !0, replace: !0, scope: { type: "@" }, controller: "UibTabsetController", templateUrl: "template/tabs/tabset.html", link: function (a, b, c) { a.vertical = angular.isDefined(c.vertical) ? a.$parent.$eval(c.vertical) : !1, a.justified = angular.isDefined(c.justified) ? a.$parent.$eval(c.justified) : !1 } } }).directive("uibTab", ["$parse", function (a) { return { require: "^uibTabset", replace: !0, templateUrl: "template/tabs/tab.html", transclude: !0, scope: { active: "=?", heading: "@", onSelect: "&select", onDeselect: "&deselect" }, controller: function () { }, controllerAs: "tab", link: function (b, c, d, e, f) { b.$watch("active", function (a) { a && e.select(b) }), b.disabled = !1, d.disable && b.$parent.$watch(a(d.disable), function (a) { b.disabled = !!a }), b.select = function () { b.disabled || (b.active = !0) }, e.addTab(b), b.$on("$destroy", function () { e.removeTab(b) }), b.$transcludeFn = f } } }]).directive("uibTabHeadingTransclude", function () { return { restrict: "A", require: "^uibTab", link: function (a, b) { a.$watch("headingElement", function (a) { a && (b.html(""), b.append(a)) }) } } }).directive("uibTabContentTransclude", function () { function a(a) { return a.tagName && (a.hasAttribute("uib-tab-heading") || a.hasAttribute("data-uib-tab-heading") || a.hasAttribute("x-uib-tab-heading") || "uib-tab-heading" === a.tagName.toLowerCase() || "data-uib-tab-heading" === a.tagName.toLowerCase() || "x-uib-tab-heading" === a.tagName.toLowerCase()) } return { restrict: "A", require: "^uibTabset", link: function (b, c, d) { var e = b.$eval(d.uibTabContentTransclude); e.$transcludeFn(e.$parent, function (b) { angular.forEach(b, function (b) { a(b) ? e.headingElement = b : c.append(b) }) }) } } }), angular.module("ui.bootstrap.timepicker", []).constant("uibTimepickerConfig", { hourStep: 1, minuteStep: 1, secondStep: 1, showMeridian: !0, showSeconds: !1, meridians: null, readonlyInput: !1, mousewheel: !0, arrowkeys: !0, showSpinners: !0 }).controller("UibTimepickerController", ["$scope", "$element", "$attrs", "$parse", "$log", "$locale", "uibTimepickerConfig", function (a, b, c, d, e, f, g) { function h() { var b = parseInt(a.hours, 10), c = a.showMeridian ? b > 0 && 13 > b : b >= 0 && 24 > b; return c ? (a.showMeridian && (12 === b && (b = 0), a.meridian === t[1] && (b += 12)), b) : void 0 } function i() { var b = parseInt(a.minutes, 10); return b >= 0 && 60 > b ? b : void 0 } function j() { var b = parseInt(a.seconds, 10); return b >= 0 && 60 > b ? b : void 0 } function k(a) { return null === a ? "" : angular.isDefined(a) && a.toString().length < 2 ? "0" + a : a.toString() } function l(a) { m(), s.$setViewValue(new Date(r)), n(a) } function m() { s.$setValidity("time", !0), a.invalidHours = !1, a.invalidMinutes = !1, a.invalidSeconds = !1 } function n(b) { if (s.$modelValue) { var c = r.getHours(), d = r.getMinutes(), e = r.getSeconds(); a.showMeridian && (c = 0 === c || 12 === c ? 12 : c % 12), a.hours = "h" === b ? c : k(c), "m" !== b && (a.minutes = k(d)), a.meridian = r.getHours() < 12 ? t[0] : t[1], "s" !== b && (a.seconds = k(e)), a.meridian = r.getHours() < 12 ? t[0] : t[1] } else a.hours = null, a.minutes = null, a.seconds = null, a.meridian = t[0] } function o(a) { r = q(r, a), l() } function p(a, b) { return q(a, 60 * b) } function q(a, b) { var c = new Date(a.getTime() + 1e3 * b), d = new Date(a); return d.setHours(c.getHours(), c.getMinutes(), c.getSeconds()), d } var r = new Date, s = { $setViewValue: angular.noop }, t = angular.isDefined(c.meridians) ? a.$parent.$eval(c.meridians) : g.meridians || f.DATETIME_FORMATS.AMPMS; a.tabindex = angular.isDefined(c.tabindex) ? c.tabindex : 0, b.removeAttr("tabindex"), this.init = function (b, d) { s = b, s.$render = this.render, s.$formatters.unshift(function (a) { return a ? new Date(a) : null }); var e = d.eq(0), f = d.eq(1), h = d.eq(2), i = angular.isDefined(c.mousewheel) ? a.$parent.$eval(c.mousewheel) : g.mousewheel; i && this.setupMousewheelEvents(e, f, h); var j = angular.isDefined(c.arrowkeys) ? a.$parent.$eval(c.arrowkeys) : g.arrowkeys; j && this.setupArrowkeyEvents(e, f, h), a.readonlyInput = angular.isDefined(c.readonlyInput) ? a.$parent.$eval(c.readonlyInput) : g.readonlyInput, this.setupInputEvents(e, f, h) }; var u = g.hourStep; c.hourStep && a.$parent.$watch(d(c.hourStep), function (a) { u = parseInt(a, 10) }); var v = g.minuteStep; c.minuteStep && a.$parent.$watch(d(c.minuteStep), function (a) { v = parseInt(a, 10) }); var w; a.$parent.$watch(d(c.min), function (a) { var b = new Date(a); w = isNaN(b) ? void 0 : b }); var x; a.$parent.$watch(d(c.max), function (a) { var b = new Date(a); x = isNaN(b) ? void 0 : b }); var y = !1; c.ngDisabled && a.$parent.$watch(d(c.ngDisabled), function (a) { y = a }), a.noIncrementHours = function () { var a = p(r, 60 * u); return y || a > x || r > a && w > a }, a.noDecrementHours = function () { var a = p(r, 60 * -u); return y || w > a || a > r && a > x }, a.noIncrementMinutes = function () { var a = p(r, v); return y || a > x || r > a && w > a }, a.noDecrementMinutes = function () { var a = p(r, -v); return y || w > a || a > r && a > x }, a.noIncrementSeconds = function () { var a = q(r, z); return y || a > x || r > a && w > a }, a.noDecrementSeconds = function () { var a = q(r, -z); return y || w > a || a > r && a > x }, a.noToggleMeridian = function () { return r.getHours() < 12 ? y || p(r, 720) > x : y || p(r, -720) < w }; var z = g.secondStep; c.secondStep && a.$parent.$watch(d(c.secondStep), function (a) { z = parseInt(a, 10) }), a.showSeconds = g.showSeconds, c.showSeconds && a.$parent.$watch(d(c.showSeconds), function (b) { a.showSeconds = !!b }), a.showMeridian = g.showMeridian, c.showMeridian && a.$parent.$watch(d(c.showMeridian), function (b) { if (a.showMeridian = !!b, s.$error.time) { var c = h(), d = i(); angular.isDefined(c) && angular.isDefined(d) && (r.setHours(c), l()) } else n() }), this.setupMousewheelEvents = function (b, c, d) { var e = function (a) { a.originalEvent && (a = a.originalEvent); var b = a.wheelDelta ? a.wheelDelta : -a.deltaY; return a.detail || b > 0 }; b.bind("mousewheel wheel", function (b) { y || a.$apply(e(b) ? a.incrementHours() : a.decrementHours()), b.preventDefault() }), c.bind("mousewheel wheel", function (b) { y || a.$apply(e(b) ? a.incrementMinutes() : a.decrementMinutes()), b.preventDefault() }), d.bind("mousewheel wheel", function (b) { y || a.$apply(e(b) ? a.incrementSeconds() : a.decrementSeconds()), b.preventDefault() }) }, this.setupArrowkeyEvents = function (b, c, d) { b.bind("keydown", function (b) { y || (38 === b.which ? (b.preventDefault(), a.incrementHours(), a.$apply()) : 40 === b.which && (b.preventDefault(), a.decrementHours(), a.$apply())) }), c.bind("keydown", function (b) { y || (38 === b.which ? (b.preventDefault(), a.incrementMinutes(), a.$apply()) : 40 === b.which && (b.preventDefault(), a.decrementMinutes(), a.$apply())) }), d.bind("keydown", function (b) { y || (38 === b.which ? (b.preventDefault(), a.incrementSeconds(), a.$apply()) : 40 === b.which && (b.preventDefault(), a.decrementSeconds(), a.$apply())) }) }, this.setupInputEvents = function (b, c, d) { if (a.readonlyInput) return a.updateHours = angular.noop, a.updateMinutes = angular.noop, void (a.updateSeconds = angular.noop); var e = function (b, c, d) { s.$setViewValue(null), s.$setValidity("time", !1), angular.isDefined(b) && (a.invalidHours = b), angular.isDefined(c) && (a.invalidMinutes = c), angular.isDefined(d) && (a.invalidSeconds = d) }; a.updateHours = function () { var a = h(), b = i(); s.$setDirty(), angular.isDefined(a) && angular.isDefined(b) ? (r.setHours(a), r.setMinutes(b), w > r || r > x ? e(!0) : l("h")) : e(!0) }, b.bind("blur", function (b) { s.$setTouched(), null === a.hours || "" === a.hours ? e(!0) : !a.invalidHours && a.hours < 10 && a.$apply(function () { a.hours = k(a.hours) }) }), a.updateMinutes = function () { var a = i(), b = h(); s.$setDirty(), angular.isDefined(a) && angular.isDefined(b) ? (r.setHours(b), r.setMinutes(a), w > r || r > x ? e(void 0, !0) : l("m")) : e(void 0, !0) }, c.bind("blur", function (b) { s.$setTouched(), null === a.minutes ? e(void 0, !0) : !a.invalidMinutes && a.minutes < 10 && a.$apply(function () { a.minutes = k(a.minutes) }) }), a.updateSeconds = function () { var a = j(); s.$setDirty(), angular.isDefined(a) ? (r.setSeconds(a), l("s")) : e(void 0, void 0, !0) }, d.bind("blur", function (b) { !a.invalidSeconds && a.seconds < 10 && a.$apply(function () { a.seconds = k(a.seconds) }) }) }, this.render = function () { var b = s.$viewValue; isNaN(b) ? (s.$setValidity("time", !1), e.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (b && (r = b), w > r || r > x ? (s.$setValidity("time", !1), a.invalidHours = !0, a.invalidMinutes = !0) : m(), n()) }, a.showSpinners = angular.isDefined(c.showSpinners) ? a.$parent.$eval(c.showSpinners) : g.showSpinners, a.incrementHours = function () { a.noIncrementHours() || o(60 * u * 60) }, a.decrementHours = function () { a.noDecrementHours() || o(60 * -u * 60) }, a.incrementMinutes = function () { a.noIncrementMinutes() || o(60 * v) }, a.decrementMinutes = function () { a.noDecrementMinutes() || o(60 * -v) }, a.incrementSeconds = function () { a.noIncrementSeconds() || o(z) }, a.decrementSeconds = function () { a.noDecrementSeconds() || o(-z) }, a.toggleMeridian = function () { var b = i(), c = h(); a.noToggleMeridian() || (angular.isDefined(b) && angular.isDefined(c) ? o(720 * (r.getHours() < 12 ? 60 : -60)) : a.meridian = a.meridian === t[0] ? t[1] : t[0]) }, a.blur = function () { s.$setTouched() } }]).directive("uibTimepicker", function () { return { require: ["uibTimepicker", "?^ngModel"], controller: "UibTimepickerController", controllerAs: "timepicker", replace: !0, scope: {}, templateUrl: function (a, b) { return b.templateUrl || "uib/template/timepicker/timepicker.html" }, link: function (a, b, c, d) { var e = d[0], f = d[1]; f && e.init(f, b.find("input")) } } }), angular.module("ui.bootstrap.typeahead", ["ui.bootstrap.debounce", "ui.bootstrap.position"]).factory("uibTypeaheadParser", ["$parse", function (a) { var b = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/; return { parse: function (c) { var d = c.match(b); if (!d) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + c + '".'); return { itemName: d[3], source: a(d[4]), viewMapper: a(d[2] || d[1]), modelMapper: a(d[1]) } } } }]).controller("UibTypeaheadController", ["$scope", "$element", "$attrs", "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$$debounce", "$uibPosition", "uibTypeaheadParser", function (a, b, c, d, e, f, g, h, i, j, k, l, m) { function n() { N.moveInProgress || (N.moveInProgress = !0, N.$digest()), Y() } function o() { N.position = D ? l.offset(b) : l.position(b), N.position.top += b.prop("offsetHeight") } var p, q, r = [9, 13, 27, 38, 40], s = 200, t = a.$eval(c.typeaheadMinLength); t || 0 === t || (t = 1); var u = a.$eval(c.typeaheadWaitMs) || 0, v = a.$eval(c.typeaheadEditable) !== !1; a.$watch(c.typeaheadEditable, function (a) { v = a !== !1 }); var w, x, y = e(c.typeaheadLoading).assign || angular.noop, z = e(c.typeaheadOnSelect), A = angular.isDefined(c.typeaheadSelectOnBlur) ? a.$eval(c.typeaheadSelectOnBlur) : !1, B = e(c.typeaheadNoResults).assign || angular.noop, C = c.typeaheadInputFormatter ? e(c.typeaheadInputFormatter) : void 0, D = c.typeaheadAppendToBody ? a.$eval(c.typeaheadAppendToBody) : !1, E = c.typeaheadAppendTo ? a.$eval(c.typeaheadAppendTo) : null, F = a.$eval(c.typeaheadFocusFirst) !== !1, G = c.typeaheadSelectOnExact ? a.$eval(c.typeaheadSelectOnExact) : !1, H = e(c.typeaheadIsOpen).assign || angular.noop, I = a.$eval(c.typeaheadShowHint) || !1, J = e(c.ngModel), K = e(c.ngModel + "($$$p)"), L = function (b, c) { return angular.isFunction(J(a)) && q && q.$options && q.$options.getterSetter ? K(b, { $$$p: c }) : J.assign(b, c) }, M = m.parse(c.uibTypeahead), N = a.$new(), O = a.$on("$destroy", function () { N.$destroy() }); N.$on("$destroy", O); var P = "typeahead-" + N.$id + "-" + Math.floor(1e4 * Math.random()); b.attr({ "aria-autocomplete": "list", "aria-expanded": !1, "aria-owns": P }); var Q, R; I && (Q = angular.element("<div></div>"), Q.css("position", "relative"), b.after(Q), R = b.clone(), R.attr("placeholder", ""), R.val(""), R.css({ position: "absolute", top: "0px", left: "0px", "border-color": "transparent", "box-shadow": "none", opacity: 1, background: "none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)", color: "#999" }), b.css({ position: "relative", "vertical-align": "top", "background-color": "transparent" }), Q.append(R), R.after(b)); var S = angular.element("<div uib-typeahead-popup></div>"); S.attr({ id: P, matches: "matches", active: "activeIdx", select: "select(activeIdx, evt)", "move-in-progress": "moveInProgress", query: "query", position: "position", "assign-is-open": "assignIsOpen(isOpen)", debounce: "debounceUpdate" }), angular.isDefined(c.typeaheadTemplateUrl) && S.attr("template-url", c.typeaheadTemplateUrl), angular.isDefined(c.typeaheadPopupTemplateUrl) && S.attr("popup-template-url", c.typeaheadPopupTemplateUrl); var T = function () { I && R.val("") }, U = function () { N.matches = [], N.activeIdx = -1, b.attr("aria-expanded", !1), T() }, V = function (a) { return P + "-option-" + a }; N.$watch("activeIdx", function (a) { 0 > a ? b.removeAttr("aria-activedescendant") : b.attr("aria-activedescendant", V(a)) }); var W = function (a, b) { return N.matches.length > b && a ? a.toUpperCase() === N.matches[b].label.toUpperCase() : !1 }, X = function (c, d) { var e = { $viewValue: c }; y(a, !0), B(a, !1), f.when(M.source(a, e)).then(function (f) { var g = c === p.$viewValue; if (g && w) if (f && f.length > 0) { N.activeIdx = F ? 0 : -1, B(a, !1), N.matches.length = 0; for (var h = 0; h < f.length; h++) e[M.itemName] = f[h], N.matches.push({ id: V(h), label: M.viewMapper(N, e), model: f[h] }); if (N.query = c, o(), b.attr("aria-expanded", !0), G && 1 === N.matches.length && W(c, 0) && (angular.isNumber(N.debounceUpdate) || angular.isObject(N.debounceUpdate) ? k(function () { N.select(0, d) }, angular.isNumber(N.debounceUpdate) ? N.debounceUpdate : N.debounceUpdate["default"]) : N.select(0, d)), I) { var i = N.matches[0].label; c.length > 0 && i.slice(0, c.length).toUpperCase() === c.toUpperCase() ? R.val(c + i.slice(c.length)) : R.val("") } } else U(), B(a, !0); g && y(a, !1) }, function () { U(), y(a, !1), B(a, !0) }) }; D && (angular.element(i).on("resize", n), h.find("body").on("scroll", n)); var Y = k(function () { N.matches.length && o(), N.moveInProgress = !1 }, s); N.moveInProgress = !1, N.query = void 0; var Z, $ = function (a) { Z = g(function () { X(a) }, u) }, _ = function () { Z && g.cancel(Z) }; U(), N.assignIsOpen = function (b) { H(a, b) }, N.select = function (d, e) { var f, h, i = {}; x = !0, i[M.itemName] = h = N.matches[d].model, f = M.modelMapper(a, i), L(a, f), p.$setValidity("editable", !0), p.$setValidity("parse", !0), z(a, { $item: h, $model: f, $label: M.viewMapper(a, i), $event: e }), U(), N.$eval(c.typeaheadFocusOnSelect) !== !1 && g(function () { b[0].focus() }, 0, !1) }, b.on("keydown", function (a) { if (0 !== N.matches.length && -1 !== r.indexOf(a.which)) { if (-1 === N.activeIdx && (9 === a.which || 13 === a.which)) return U(), void N.$digest(); switch (a.preventDefault(), a.which) { case 9: case 13: N.$apply(function () { angular.isNumber(N.debounceUpdate) || angular.isObject(N.debounceUpdate) ? k(function () { N.select(N.activeIdx, a) }, angular.isNumber(N.debounceUpdate) ? N.debounceUpdate : N.debounceUpdate["default"]) : N.select(N.activeIdx, a) }); break; case 27: a.stopPropagation(), U(), N.$digest(); break; case 38: N.activeIdx = (N.activeIdx > 0 ? N.activeIdx : N.matches.length) - 1, N.$digest(), S.find("li")[N.activeIdx].scrollIntoView(!1); break; case 40: N.activeIdx = (N.activeIdx + 1) % N.matches.length, N.$digest(), S.find("li")[N.activeIdx].scrollIntoView(!1) } } }), b.bind("focus", function (a) { w = !0, 0 !== t || p.$viewValue || g(function () { X(p.$viewValue, a) }, 0) }), b.bind("blur", function (a) { A && N.matches.length && -1 !== N.activeIdx && !x && (x = !0, N.$apply(function () { angular.isObject(N.debounceUpdate) && angular.isNumber(N.debounceUpdate.blur) ? k(function () { N.select(N.activeIdx, a) }, N.debounceUpdate.blur) : N.select(N.activeIdx, a) })), !v && p.$error.editable && (p.$viewValue = "", b.val("")), w = !1, x = !1 }); var aa = function (a) { b[0] !== a.target && 3 !== a.which && 0 !== N.matches.length && (U(), j.$$phase || N.$digest()) }; h.on("click", aa), a.$on("$destroy", function () { h.off("click", aa), (D || E) && ba.remove(), D && (angular.element(i).off("resize", n), h.find("body").off("scroll", n)), S.remove(), I && Q.remove() }); var ba = d(S)(N); D ? h.find("body").append(ba) : E ? angular.element(E).eq(0).append(ba) : b.after(ba), this.init = function (b, c) { p = b, q = c, N.debounceUpdate = p.$options && e(p.$options.debounce)(a), p.$parsers.unshift(function (b) { return w = !0, 0 === t || b && b.length >= t ? u > 0 ? (_(), $(b)) : X(b) : (y(a, !1), _(), U()), v ? b : b ? void p.$setValidity("editable", !1) : (p.$setValidity("editable", !0), null) }), p.$formatters.push(function (b) { var c, d, e = {}; return v || p.$setValidity("editable", !0), C ? (e.$model = b, C(a, e)) : (e[M.itemName] = b, c = M.viewMapper(a, e), e[M.itemName] = void 0, d = M.viewMapper(a, e), c !== d ? c : b) }) } }]).directive("uibTypeahead", function () { return { controller: "UibTypeaheadController", require: ["ngModel", "^?ngModelOptions", "uibTypeahead"], link: function (a, b, c, d) { d[2].init(d[0], d[1]) } } }).directive("uibTypeaheadPopup", ["$$debounce", function (a) { return { scope: { matches: "=", query: "=", active: "=", position: "&", moveInProgress: "=", select: "&", assignIsOpen: "&", debounce: "&" }, replace: !0, templateUrl: function (a, b) { return b.popupTemplateUrl || "uib/template/typeahead/typeahead-popup.html" }, link: function (b, c, d) { b.templateUrl = d.templateUrl, b.isOpen = function () { var a = b.matches.length > 0; return b.assignIsOpen({ isOpen: a }), a }, b.isActive = function (a) { return b.active === a }, b.selectActive = function (a) { b.active = a }, b.selectMatch = function (c, d) { var e = b.debounce(); angular.isNumber(e) || angular.isObject(e) ? a(function () { b.select({ activeIdx: c, evt: d }) }, angular.isNumber(e) ? e : e["default"]) : b.select({ activeIdx: c, evt: d }) } } } }]).directive("uibTypeaheadMatch", ["$templateRequest", "$compile", "$parse", function (a, b, c) { return { scope: { index: "=", match: "=", query: "=" }, link: function (d, e, f) { var g = c(f.templateUrl)(d.$parent) || "uib/template/typeahead/typeahead-match.html"; a(g).then(function (a) { var c = angular.element(a.trim()); e.replaceWith(c), b(c)(d) }) } } }]).filter("uibTypeaheadHighlight", ["$sce", "$injector", "$log", function (a, b, c) { function d(a) { return a.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1") } function e(a) { return /<.*>/g.test(a) } var f; return f = b.has("$sanitize"), function (b, g) { return !f && e(b) && c.warn("Unsafe use of typeahead please use ngSanitize"), b = g ? ("" + b).replace(new RegExp(d(g), "gi"), "<strong>$&</strong>") : b, f || (b = a.trustAsHtml(b)), b } }]), angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function (a) { a.put("uib/template/accordion/accordion-group.html", '<div class="panel" ng-class="panelClass || \'panel-default\'">\n  <div class="panel-heading" ng-keypress="toggleOpen($event)">\n    <h4 class="panel-title">\n      <div tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading"><span ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></div>\n    </h4>\n  </div>\n  <div class="panel-collapse collapse" uib-collapse="!isOpen">\n	  <div class="panel-body" ng-transclude></div>\n  </div>\n</div>\n') }]), angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function (a) { a.put("uib/template/accordion/accordion.html", '<div class="panel-group" ng-transclude></div>') }]), angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function (a) { a.put("uib/template/alert/alert.html", '<div class="alert" ng-class="[\'alert-\' + (type || \'warning\'), closeable ? \'alert-dismissible\' : null]" role="alert">\n    <button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n        <span aria-hidden="true">&times;</span>\n        <span class="sr-only">Close</span>\n    </button>\n    <div ng-transclude></div>\n</div>\n') }]), angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function (a) { a.put("uib/template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n  <div class="carousel-inner" ng-transclude></div>\n  <a role="button" href class="left carousel-control" ng-click="prev()" ng-show="slides.length > 1">\n    <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n    <span class="sr-only">previous</span>\n  </a>\n  <a role="button" href class="right carousel-control" ng-click="next()" ng-show="slides.length > 1">\n    <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n    <span class="sr-only">next</span>\n  </a>\n  <ol class="carousel-indicators" ng-show="slides.length > 1">\n    <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n      <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n    </li>\n  </ol>\n</div>') }]), angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function (a) { a.put("uib/template/carousel/slide.html", '<div ng-class="{\n    \'active\': active\n  }" class="item text-center" ng-transclude></div>\n') }]), angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/datepicker.html", '<div class="uib-datepicker" ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n  <uib-daypicker ng-switch-when="day" tabindex="0"></uib-daypicker>\n  <uib-monthpicker ng-switch-when="month" tabindex="0"></uib-monthpicker>\n  <uib-yearpicker ng-switch-when="year" tabindex="0"></uib-yearpicker>\n</div>') }]), angular.module("template/datepicker/day.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/day.html", '<table class="uib-daypicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr>\n      <th ng-if="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-weeks" ng-repeat="row in rows track by $index">\n      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" style="min-width:100%;" class="btn btn-default btn-sm"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("template/datepicker/month.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/month.html", '<table class="uib-monthpicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-months" ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" style="min-width:100%;" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("template/datepicker/popup.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/popup.html", '<ul class="uib-datepicker-popup dropdown-menu" dropdown-nested ng-if="isOpen" style="display: block" ng-style="{top: position.top+\'px\', left: position.left+\'px\'}" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n	<li ng-transclude></li>\n	<li ng-if="showButtonBar" style="padding:10px 9px 2px" class="uib-button-bar">\n		<span class="btn-group pull-left">\n			<button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\')" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n			<button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null)">{{ getText(\'clear\') }}</button>\n		</span>\n		<button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close()">{{ getText(\'close\') }}</button>\n	</li>\n</ul>\n') }]), angular.module("template/datepicker/year.html", []).run(["$templateCache", function (a) { a.put("template/datepicker/year.html", '<table class="uib-yearpicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-years" ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" style="min-width:100%;" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function (a) {
//    a.put("uib/template/modal/backdrop.html", '<div class="modal-backdrop"\n     uib-modal-animation-class="fade"\n     modal-in-class="in"\n     ng-style="{\'z-index\': 1040 + (index && 1 || 0) + index*10}"\n></div>\n');
//}]), angular.module("uib/template/modal/window.html", []).run(["$templateCache", function (a) { a.put("uib/template/modal/window.html", '<div modal-render="{{$isRendered}}" tabindex="-1" role="dialog" class="modal"\n    uib-modal-animation-class="fade"\n    modal-in-class="in"\n    ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}">\n    <div class="modal-dialog" ng-class="size ? \'modal-\' + size : \'\'"><div class="modal-content" uib-modal-transclude></div></div>\n</div>\n') }]), angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function (a) { a.put("uib/template/pager/pager.html", '<ul class="pager">\n  <li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n  <li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n</ul>\n') }]), angular.module("uib/template/pagination/pager.html", []).run(["$templateCache", function (a) { a.put("uib/template/pagination/pager.html", '<ul class="pager">\n  <li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n  <li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n</ul>\n') }]), angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function (a) { a.put("uib/template/pagination/pagination.html", '<ul class="pagination">\n  <li ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)">{{::getText(\'first\')}}</a></li>\n  <li ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)">{{page.text}}</a></li>\n  <li ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n  <li ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)">{{::getText(\'last\')}}</a></li>\n</ul>\n') }]), angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function (a) { a.put("uib/template/tooltip/tooltip-html-popup.html", '<div class="tooltip"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n</div>\n') }]), angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function (a) { a.put("uib/template/tooltip/tooltip-popup.html", '<div class="tooltip"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind="content"></div>\n</div>\n') }]), angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function (a) { a.put("uib/template/tooltip/tooltip-template-popup.html", '<div class="tooltip"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner"\n    uib-tooltip-template-transclude="contentExp()"\n    tooltip-template-transclude-scope="originScope()"></div>\n</div>\n') }]), angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function (a) { a.put("uib/template/popover/popover-html.html", '<div class="popover"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content" ng-bind-html="contentExp()"></div>\n  </div>\n</div>\n') }]), angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function (a) { a.put("uib/template/popover/popover-template.html", '<div class="popover"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content"\n        uib-tooltip-template-transclude="contentExp()"\n        tooltip-template-transclude-scope="originScope()"></div>\n  </div>\n</div>\n') }]), angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function (a) { a.put("uib/template/popover/popover.html", '<div class="popover"\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content" ng-bind="content"></div>\n  </div>\n</div>\n') }]), angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function (a) { a.put("uib/template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n') }]), angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function (a) { a.put("uib/template/progressbar/progress.html", '<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>') }]), angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function (a) { a.put("uib/template/progressbar/progressbar.html", '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n</div>\n') }]), angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function (a) { a.put("uib/template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}">\n    <span ng-repeat-start="r in range track by $index" class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}" aria-valuetext="{{r.title}}"></i>\n</span>\n') }]), angular.module("template/tabs/tab.html", []).run(["$templateCache", function (a) { a.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}" class="uib-tab">\n  <div ng-click="select()" uib-tab-heading-transclude>{{heading}}</div>\n</li>\n') }]), angular.module("template/tabs/tabset.html", []).run(["$templateCache", function (a) { a.put("template/tabs/tabset.html", '<div>\n  <ul class="nav nav-{{type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane" \n         ng-repeat="tab in tabs" \n         ng-class="{active: tab.active}"\n         uib-tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n') }]), angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function (a) { a.put("uib/template/timepicker/timepicker.html", '<table class="uib-timepicker">\n  <tbody>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-increment hours"><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-increment minutes"><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-increment seconds"><a ng-click="incrementSeconds()" ng-class="{disabled: noIncrementSeconds()}" class="btn btn-link" ng-disabled="noIncrementSeconds()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n    <tr>\n      <td class="form-group uib-time hours" ng-class="{\'has-error\': invalidHours}">\n        <input style="width:50px;" type="text" placeholder="HH" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="disabled" ng-blur="blur()">\n      </td>\n      <td class="uib-separator">:</td>\n      <td class="form-group uib-time minutes" ng-class="{\'has-error\': invalidMinutes}">\n        <input style="width:50px;" type="text" placeholder="MM" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="disabled" ng-blur="blur()">\n      </td>\n      <td ng-show="showSeconds" class="uib-separator">:</td>\n      <td class="form-group uib-time seconds" ng-class="{\'has-error\': invalidSeconds}" ng-show="showSeconds">\n        <input style="width:50px;" type="text" ng-model="seconds" ng-change="updateSeconds()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="disabled" ng-blur="blur()">\n      </td>\n      <td ng-show="showMeridian" class="uib-time am-pm"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n    </tr>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-decrement hours"><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-decrement minutes"><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-decrement seconds"><a ng-click="decrementSeconds()" ng-class="{disabled: noDecrementSeconds()}" class="btn btn-link" ng-disabled="noDecrementSeconds()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function (a) { a.put("uib/template/typeahead/typeahead-match.html", '<a href tabindex="-1" ng-bind-html="match.label | uibTypeaheadHighlight:query"></a>\n') }]), angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function (a) { a.put("uib/template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" style="display: block;" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n') }]), angular.module("ui.bootstrap.carousel").run(function () { !angular.$$csp() && angular.element(document).find("head").prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>') });

/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 1.0.0 - 2016-01-08
 * License: MIT
 */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "uib/template/modal/backdrop.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])

  .directive('uibCollapse', ['$animate', '$injector', function ($animate, $injector) {
      var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
      return {
          link: function (scope, element, attrs) {
              if (!scope.$eval(attrs.uibCollapse)) {
                  element.addClass('in')
                    .addClass('collapse')
                    .css({ height: 'auto' });
              }

              function expand() {
                  element.removeClass('collapse')
                    .addClass('collapsing')
                    .attr('aria-expanded', true)
                    .attr('aria-hidden', false);

                  if ($animateCss) {
                      $animateCss(element, {
                          addClass: 'in',
                          easing: 'ease',
                          to: { height: element[0].scrollHeight + 'px' }
                      }).start()['finally'](expandDone);
                  } else {
                      $animate.addClass(element, 'in', {
                          to: { height: element[0].scrollHeight + 'px' }
                      }).then(expandDone);
                  }
              }

              function expandDone() {
                  element.removeClass('collapsing')
                    .addClass('collapse')
                    .css({ height: 'auto' });
              }

              function collapse() {
                  if (!element.hasClass('collapse') && !element.hasClass('in')) {
                      return collapseDone();
                  }

                  element
                    // IMPORTANT: The height must be set before adding "collapsing" class.
                    // Otherwise, the browser attempts to animate from height 0 (in
                    // collapsing class) to the given height here.
                    .css({ height: element[0].scrollHeight + 'px' })
                    // initially all panel collapse have the collapse class, this removal
                    // prevents the animation from jumping to collapsed state
                    .removeClass('collapse')
                    .addClass('collapsing')
                    .attr('aria-expanded', false)
                    .attr('aria-hidden', true);

                  if ($animateCss) {
                      $animateCss(element, {
                          removeClass: 'in',
                          to: { height: '0' }
                      }).start()['finally'](collapseDone);
                  } else {
                      $animate.removeClass(element, 'in', {
                          to: { height: '0' }
                      }).then(collapseDone);
                  }
              }

              function collapseDone() {
                  element.css({ height: '0' }); // Required so that collapse works when animation is disabled
                  element.removeClass('collapsing')
                    .addClass('collapse');
              }

              scope.$watch(attrs.uibCollapse, function (shouldCollapse) {
                  if (shouldCollapse) {
                      collapse();
                  } else {
                      expand();
                  }
              });
          }
      };
  }]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('uibAccordionConfig', {
    closeOthers: true
})

.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function ($scope, $attrs, accordionConfig) {
    // This array keeps track of the accordion groups
    this.groups = [];

    // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
    this.closeOthers = function (openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ?
          $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
            angular.forEach(this.groups, function (group) {
                if (group !== openGroup) {
                    group.isOpen = false;
                }
            });
        }
    };

    // This is called from the accordion-group directive to add itself to the accordion
    this.addGroup = function (groupScope) {
        var that = this;
        this.groups.push(groupScope);

        groupScope.$on('$destroy', function (event) {
            that.removeGroup(groupScope);
        });
    };

    // This is called from the accordion-group directive when to remove itself
    this.removeGroup = function (group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
            this.groups.splice(index, 1);
        }
    };
}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('uibAccordion', function () {
    return {
        controller: 'UibAccordionController',
        controllerAs: 'accordion',
        transclude: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/accordion/accordion.html';
        }
    };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('uibAccordionGroup', function () {
    return {
        require: '^uibAccordion',         // We need this directive to be inside an accordion
        transclude: true,              // It transcludes the contents of the directive into the template
        replace: true,                // The element containing the directive will be replaced with the template
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
        },
        scope: {
            heading: '@',               // Interpolate the heading attribute onto this scope
            isOpen: '=?',
            isDisabled: '=?'
        },
        controller: function () {
            this.setHeading = function (element) {
                this.heading = element;
            };
        },
        link: function (scope, element, attrs, accordionCtrl) {
            accordionCtrl.addGroup(scope);

            scope.openClass = attrs.openClass || 'panel-open';
            scope.panelClass = attrs.panelClass || 'panel-default';
            scope.$watch('isOpen', function (value) {
                element.toggleClass(scope.openClass, !!value);
                if (value) {
                    accordionCtrl.closeOthers(scope);
                }
            });

            scope.toggleOpen = function ($event) {
                if (!scope.isDisabled) {
                    if (!$event || $event.which === 32) {
                        scope.isOpen = !scope.isOpen;
                    }
                }
            };
        }
    };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
.directive('uibAccordionHeading', function () {
    return {
        transclude: true,   // Grab the contents to be used as the heading
        template: '',       // In effect remove this element!
        replace: true,
        require: '^uibAccordionGroup',
        link: function (scope, element, attrs, accordionGroupCtrl, transclude) {
            // Pass the heading to the accordion-group controller
            // so that it can be transcluded into the right place in the template
            // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
.directive('uibAccordionTransclude', function () {
    return {
        require: '^uibAccordionGroup',
        link: function (scope, element, attrs, controller) {
            scope.$watch(function () { return controller[attrs.uibAccordionTransclude]; }, function (heading) {
                if (heading) {
                    element.find('span').html('');
                    element.find('span').append(heading);
                }
            });
        }
    };
});

angular.module('ui.bootstrap.alert', [])

.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function ($scope, $attrs, $interpolate, $timeout) {
    $scope.closeable = !!$attrs.close;

    var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
      $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

    if (dismissOnTimeout) {
        $timeout(function () {
            $scope.close();
        }, parseInt(dismissOnTimeout, 10));
    }
}])

.directive('uibAlert', function () {
    return {
        controller: 'UibAlertController',
        controllerAs: 'alert',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/alert/alert.html';
        },
        transclude: true,
        replace: true,
        scope: {
            type: '@',
            close: '&'
        }
    };
});

angular.module('ui.bootstrap.buttons', [])

.constant('uibButtonConfig', {
    activeClass: 'active',
    toggleEvent: 'click'
})

.controller('UibButtonsController', ['uibButtonConfig', function (buttonConfig) {
    this.activeClass = buttonConfig.activeClass || 'active';
    this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('uibBtnRadio', ['$parse', function ($parse) {
    return {
        require: ['uibBtnRadio', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'buttons',
        link: function (scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            var uncheckableExpr = $parse(attrs.uibUncheckable);

            element.find('input').css({ display: 'none' });

            //model -> UI
            ngModelCtrl.$render = function () {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
            };

            //ui->model
            element.on(buttonsCtrl.toggleEvent, function () {
                if (attrs.disabled) {
                    return;
                }

                var isActive = element.hasClass(buttonsCtrl.activeClass);

                if (!isActive || angular.isDefined(attrs.uncheckable)) {
                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                        ngModelCtrl.$render();
                    });
                }
            });

            if (attrs.uibUncheckable) {
                scope.$watch(uncheckableExpr, function (uncheckable) {
                    attrs.$set('uncheckable', uncheckable ? '' : null);
                });
            }
        }
    };
}])

.directive('uibBtnCheckbox', function () {
    return {
        require: ['uibBtnCheckbox', 'ngModel'],
        controller: 'UibButtonsController',
        controllerAs: 'button',
        link: function (scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

            element.find('input').css({ display: 'none' });

            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, true);
            }

            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, false);
            }

            function getCheckboxValue(attribute, defaultValue) {
                return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
            }

            //model -> UI
            ngModelCtrl.$render = function () {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            };

            //ui->model
            element.on(buttonsCtrl.toggleEvent, function () {
                if (attrs.disabled) {
                    return;
                }

                scope.$apply(function () {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
                    ngModelCtrl.$render();
                });
            });
        }
    };
});

angular.module('ui.bootstrap.carousel', [])

.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function ($scope, $element, $interval, $timeout, $animate) {
    var self = this,
      slides = self.slides = $scope.slides = [],
      SLIDE_DIRECTION = 'uib-slideDirection',
      currentIndex = -1,
      currentInterval, isPlaying, bufferedTransitions = [];
    self.currentSlide = null;

    var destroyed = false;

    self.addSlide = function (slide, element) {
        slide.$element = element;
        slides.push(slide);
        //if this is the first slide or the slide is set to active, select it
        if (slides.length === 1 || slide.active) {
            if ($scope.$currentTransition) {
                $scope.$currentTransition = null;
            }

            self.select(slides[slides.length - 1]);
            if (slides.length === 1) {
                $scope.play();
            }
        } else {
            slide.active = false;
        }
    };

    self.getCurrentIndex = function () {
        if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
            return +self.currentSlide.index;
        }
        return currentIndex;
    };

    self.next = $scope.next = function () {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;

        if (newIndex === 0 && $scope.noWrap()) {
            $scope.pause();
            return;
        }

        return self.select(getSlideByIndex(newIndex), 'next');
    };

    self.prev = $scope.prev = function () {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

        if ($scope.noWrap() && newIndex === slides.length - 1) {
            $scope.pause();
            return;
        }

        return self.select(getSlideByIndex(newIndex), 'prev');
    };

    self.removeSlide = function (slide) {
        if (angular.isDefined(slide.index)) {
            slides.sort(function (a, b) {
                return +a.index > +b.index;
            });
        }

        var bufferedIndex = bufferedTransitions.indexOf(slide);
        if (bufferedIndex !== -1) {
            bufferedTransitions.splice(bufferedIndex, 1);
        }
        //get the index of the slide inside the carousel
        var index = slides.indexOf(slide);
        slides.splice(index, 1);
        $timeout(function () {
            if (slides.length > 0 && slide.active) {
                if (index >= slides.length) {
                    self.select(slides[index - 1]);
                } else {
                    self.select(slides[index]);
                }
            } else if (currentIndex > index) {
                currentIndex--;
            }
        });

        //clean the currentSlide when no more slide
        if (slides.length === 0) {
            self.currentSlide = null;
            clearBufferedTransitions();
        }
    };

    /* direction: "prev" or "next" */
    self.select = $scope.select = function (nextSlide, direction) {
        var nextIndex = $scope.indexOfSlide(nextSlide);
        //Decide direction if it's not given
        if (direction === undefined) {
            direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
        }
        //Prevent this user-triggered transition from occurring if there is already one in progress
        if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
            goNext(nextSlide, nextIndex, direction);
        } else if (nextSlide && nextSlide !== self.currentSlide && $scope.$currentTransition) {
            bufferedTransitions.push(nextSlide);
        }
    };

    /* Allow outside people to call indexOf on slides array */
    $scope.indexOfSlide = function (slide) {
        return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
    };

    $scope.isActive = function (slide) {
        return self.currentSlide === slide;
    };

    $scope.pause = function () {
        if (!$scope.noPause) {
            isPlaying = false;
            resetTimer();
        }
    };

    $scope.play = function () {
        if (!isPlaying) {
            isPlaying = true;
            restartTimer();
        }
    };

    $scope.$on('$destroy', function () {
        destroyed = true;
        resetTimer();
    });

    $scope.$watch('noTransition', function (noTransition) {
        $animate.enabled($element, !noTransition);
    });

    $scope.$watch('interval', restartTimer);

    $scope.$watchCollection('slides', resetTransition);

    function clearBufferedTransitions() {
        while (bufferedTransitions.length) {
            bufferedTransitions.shift();
        }
    }

    function getSlideByIndex(index) {
        if (angular.isUndefined(slides[index].index)) {
            return slides[index];
        }
        for (var i = 0, l = slides.length; i < l; ++i) {
            if (slides[i].index === index) {
                return slides[i];
            }
        }
    }

    function goNext(slide, index, direction) {
        if (destroyed) { return; }

        angular.extend(slide, { direction: direction, active: true });
        angular.extend(self.currentSlide || {}, { direction: direction, active: false });
        if ($animate.enabled($element) && !$scope.$currentTransition &&
          slide.$element && self.slides.length > 1) {
            slide.$element.data(SLIDE_DIRECTION, slide.direction);
            if (self.currentSlide && self.currentSlide.$element) {
                self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
            }

            $scope.$currentTransition = true;
            $animate.on('addClass', slide.$element, function (element, phase) {
                if (phase === 'close') {
                    $scope.$currentTransition = null;
                    $animate.off('addClass', element);
                    if (bufferedTransitions.length) {
                        var nextSlide = bufferedTransitions.pop();
                        var nextIndex = $scope.indexOfSlide(nextSlide);
                        var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
                        clearBufferedTransitions();

                        goNext(nextSlide, nextIndex, nextDirection);
                    }
                }
            });
        }

        self.currentSlide = slide;
        currentIndex = index;

        //every time you change slides, reset the timer
        restartTimer();
    }

    function resetTimer() {
        if (currentInterval) {
            $interval.cancel(currentInterval);
            currentInterval = null;
        }
    }

    function resetTransition(slides) {
        if (!slides.length) {
            $scope.$currentTransition = null;
            clearBufferedTransitions();
        }
    }

    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval > 0) {
            currentInterval = $interval(timerFn, interval);
        }
    }

    function timerFn() {
        var interval = +$scope.interval;
        if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
            $scope.next();
        } else {
            $scope.pause();
        }
    }
}])

.directive('uibCarousel', function () {
    return {
        transclude: true,
        replace: true,
        controller: 'UibCarouselController',
        controllerAs: 'carousel',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/carousel/carousel.html';
        },
        scope: {
            interval: '=',
            noTransition: '=',
            noPause: '=',
            noWrap: '&'
        }
    };
})

.directive('uibSlide', function () {
    return {
        require: '^uibCarousel',
        transclude: true,
        replace: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/carousel/slide.html';
        },
        scope: {
            active: '=?',
            actual: '=?',
            index: '=?'
        },
        link: function (scope, element, attrs, carouselCtrl) {
            carouselCtrl.addSlide(scope, element);
            //when the scope is destroyed then remove the slide from the current slides array
            scope.$on('$destroy', function () {
                carouselCtrl.removeSlide(scope);
            });

            scope.$watch('active', function (active) {
                if (active) {
                    carouselCtrl.select(scope);
                }
            });
        }
    };
})

.animation('.item', ['$animateCss',
function ($animateCss) {
    var SLIDE_DIRECTION = 'uib-slideDirection';

    function removeClass(element, className, callback) {
        element.removeClass(className);
        if (callback) {
            callback();
        }
    }

    return {
        beforeAddClass: function (element, className, done) {
            if (className === 'active') {
                var stopped = false;
                var direction = element.data(SLIDE_DIRECTION);
                var directionClass = direction === 'next' ? 'left' : 'right';
                var removeClassFn = removeClass.bind(this, element,
                  directionClass + ' ' + direction, done);
                element.addClass(direction);

                $animateCss(element, { addClass: directionClass })
                  .start()
                  .done(removeClassFn);

                return function () {
                    stopped = true;
                };
            }
            done();
        },
        beforeRemoveClass: function (element, className, done) {
            if (className === 'active') {
                var stopped = false;
                var direction = element.data(SLIDE_DIRECTION);
                var directionClass = direction === 'next' ? 'left' : 'right';
                var removeClassFn = removeClass.bind(this, element, directionClass, done);

                $animateCss(element, { addClass: directionClass })
                  .start()
                  .done(removeClassFn);

                return function () {
                    stopped = true;
                };
            }
            done();
        }
    };
}]);

angular.module('ui.bootstrap.dateparser', [])

.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function ($log, $locale, orderByFilter) {
    // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
    var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

    var localeId;
    var formatCodeToRegex;

    this.init = function () {
        localeId = $locale.id;

        this.parsers = {};

        formatCodeToRegex = [
          {
              key: 'yyyy',
              regex: '\\d{4}',
              apply: function (value) { this.year = +value; }
          },
          {
              key: 'yy',
              regex: '\\d{2}',
              apply: function (value) { this.year = +value + 2000; }
          },
          {
              key: 'y',
              regex: '\\d{1,4}',
              apply: function (value) { this.year = +value; }
          },
          {
              key: 'M!',
              regex: '0?[1-9]|1[0-2]',
              apply: function (value) { this.month = value - 1; }
          },
          {
              key: 'MMMM',
              regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
              apply: function (value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
          },
          {
              key: 'MMM',
              regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
              apply: function (value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
          },
          {
              key: 'MM',
              regex: '0[1-9]|1[0-2]',
              apply: function (value) { this.month = value - 1; }
          },
          {
              key: 'M',
              regex: '[1-9]|1[0-2]',
              apply: function (value) { this.month = value - 1; }
          },
          {
              key: 'd!',
              regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
              apply: function (value) { this.date = +value; }
          },
          {
              key: 'dd',
              regex: '[0-2][0-9]{1}|3[0-1]{1}',
              apply: function (value) { this.date = +value; }
          },
          {
              key: 'd',
              regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
              apply: function (value) { this.date = +value; }
          },
          {
              key: 'EEEE',
              regex: $locale.DATETIME_FORMATS.DAY.join('|')
          },
          {
              key: 'EEE',
              regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
          },
          {
              key: 'HH',
              regex: '(?:0|1)[0-9]|2[0-3]',
              apply: function (value) { this.hours = +value; }
          },
          {
              key: 'hh',
              regex: '0[0-9]|1[0-2]',
              apply: function (value) { this.hours = +value; }
          },
          {
              key: 'H',
              regex: '1?[0-9]|2[0-3]',
              apply: function (value) { this.hours = +value; }
          },
          {
              key: 'h',
              regex: '[0-9]|1[0-2]',
              apply: function (value) { this.hours = +value; }
          },
          {
              key: 'mm',
              regex: '[0-5][0-9]',
              apply: function (value) { this.minutes = +value; }
          },
          {
              key: 'm',
              regex: '[0-9]|[1-5][0-9]',
              apply: function (value) { this.minutes = +value; }
          },
          {
              key: 'sss',
              regex: '[0-9][0-9][0-9]',
              apply: function (value) { this.milliseconds = +value; }
          },
          {
              key: 'ss',
              regex: '[0-5][0-9]',
              apply: function (value) { this.seconds = +value; }
          },
          {
              key: 's',
              regex: '[0-9]|[1-5][0-9]',
              apply: function (value) { this.seconds = +value; }
          },
          {
              key: 'a',
              regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
              apply: function (value) {
                  if (this.hours === 12) {
                      this.hours = 0;
                  }

                  if (value === 'PM') {
                      this.hours += 12;
                  }
              }
          },
          {
              key: 'Z',
              regex: '[+-]\\d{4}',
              apply: function (value) {
                  var matches = value.match(/([+-])(\d{2})(\d{2})/),
                    sign = matches[1],
                    hours = matches[2],
                    minutes = matches[3];
                  this.hours += toInt(sign + hours);
                  this.minutes += toInt(sign + minutes);
              }
          },
          {
              key: 'ww',
              regex: '[0-4][0-9]|5[0-3]'
          },
          {
              key: 'w',
              regex: '[0-9]|[1-4][0-9]|5[0-3]'
          },
          {
              key: 'GGGG',
              regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s')
          },
          {
              key: 'GGG',
              regex: $locale.DATETIME_FORMATS.ERAS.join('|')
          },
          {
              key: 'GG',
              regex: $locale.DATETIME_FORMATS.ERAS.join('|')
          },
          {
              key: 'G',
              regex: $locale.DATETIME_FORMATS.ERAS.join('|')
          }
        ];
    };

    this.init();

    function createParser(format) {
        var map = [], regex = format.split('');

        // check for literal values
        var quoteIndex = format.indexOf('\'');
        if (quoteIndex > -1) {
            var inLiteral = false;
            format = format.split('');
            for (var i = quoteIndex; i < format.length; i++) {
                if (inLiteral) {
                    if (format[i] === '\'') {
                        if (i + 1 < format.length && format[i + 1] === '\'') { // escaped single quote
                            format[i + 1] = '$';
                            regex[i + 1] = '';
                        } else { // end of literal
                            regex[i] = '';
                            inLiteral = false;
                        }
                    }
                    format[i] = '$';
                } else {
                    if (format[i] === '\'') { // start of literal
                        format[i] = '$';
                        regex[i] = '';
                        inLiteral = true;
                    }
                }
            }

            format = format.join('');
        }

        angular.forEach(formatCodeToRegex, function (data) {
            var index = format.indexOf(data.key);

            if (index > -1) {
                format = format.split('');

                regex[index] = '(' + data.regex + ')';
                format[index] = '$'; // Custom symbol to define consumed part of format
                for (var i = index + 1, n = index + data.key.length; i < n; i++) {
                    regex[i] = '';
                    format[i] = '$';
                }
                format = format.join('');

                map.push({
                    index: index,
                    apply: data.apply,
                    matcher: data.regex
                });
            }
        });

        return {
            regex: new RegExp('^' + regex.join('') + '$'),
            map: orderByFilter(map, 'index')
        };
    }

    this.parse = function (input, format, baseDate) {
        if (!angular.isString(input) || !format) {
            return input;
        }

        format = $locale.DATETIME_FORMATS[format] || format;
        format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

        if ($locale.id !== localeId) {
            this.init();
        }

        if (!this.parsers[format]) {
            this.parsers[format] = createParser(format);
        }

        var parser = this.parsers[format],
            regex = parser.regex,
            map = parser.map,
            results = input.match(regex),
            tzOffset = false;
        if (results && results.length) {
            var fields, dt;
            if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
                fields = {
                    year: baseDate.getFullYear(),
                    month: baseDate.getMonth(),
                    date: baseDate.getDate(),
                    hours: baseDate.getHours(),
                    minutes: baseDate.getMinutes(),
                    seconds: baseDate.getSeconds(),
                    milliseconds: baseDate.getMilliseconds()
                };
            } else {
                if (baseDate) {
                    $log.warn('dateparser:', 'baseDate is not a valid date');
                }
                fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
            }

            for (var i = 1, n = results.length; i < n; i++) {
                var mapper = map[i - 1];
                if (mapper.matcher === 'Z') {
                    tzOffset = true;
                }

                if (mapper.apply) {
                    mapper.apply.call(fields, results[i]);
                }
            }

            var datesetter = tzOffset ? Date.prototype.setUTCFullYear :
              Date.prototype.setFullYear;
            var timesetter = tzOffset ? Date.prototype.setUTCHours :
              Date.prototype.setHours;

            if (isValid(fields.year, fields.month, fields.date)) {
                if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
                    dt = new Date(baseDate);
                    datesetter.call(dt, fields.year, fields.month, fields.date);
                    timesetter.call(dt, fields.hours, fields.minutes,
                      fields.seconds, fields.milliseconds);
                } else {
                    dt = new Date(0);
                    datesetter.call(dt, fields.year, fields.month, fields.date);
                    timesetter.call(dt, fields.hours || 0, fields.minutes || 0,
                      fields.seconds || 0, fields.milliseconds || 0);
                }
            }

            return dt;
        }
    };

    // Check if date is valid for specific month (and year for February).
    // Month: 0 = Jan, 1 = Feb, etc
    function isValid(year, month, date) {
        if (date < 1) {
            return false;
        }

        if (month === 1 && date > 28) {
            return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
        }

        if (month === 3 || month === 5 || month === 8 || month === 10) {
            return date < 31;
        }

        return true;
    }

    function toInt(str) {
        return parseInt(str, 10);
    }

    this.toTimezone = toTimezone;
    this.fromTimezone = fromTimezone;
    this.timezoneToOffset = timezoneToOffset;
    this.addDateMinutes = addDateMinutes;
    this.convertTimezoneToLocal = convertTimezoneToLocal;

    function toTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
    }

    function fromTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
    }

    //https://github.com/angular/angular.js/blob/4daafd3dbe6a80d578f5a31df1bb99c77559543e/src/Angular.js#L1207
    function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }

    function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
    }

    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
    }
}]);

// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to
// at most one element.
angular.module('ui.bootstrap.isClass', [])
.directive('uibIsClass', [
         '$animate',
function ($animate) {
    //                    11111111          22222222
    var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
    //                    11111111           22222222
    var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;

    var dataPerTracked = {};

    return {
        restrict: 'A',
        compile: function (tElement, tAttrs) {
            var linkedScopes = [];
            var instances = [];
            var expToData = {};
            var lastActivated = null;
            var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
            var onExp = onExpMatches[2];
            var expsStr = onExpMatches[1];
            var exps = expsStr.split(',');

            return linkFn;

            function linkFn(scope, element, attrs) {
                linkedScopes.push(scope);
                instances.push({
                    scope: scope,
                    element: element
                });

                exps.forEach(function (exp, k) {
                    addForExp(exp, scope);
                });

                scope.$on('$destroy', removeScope);
            }

            function addForExp(exp, scope) {
                var matches = exp.match(IS_REGEXP);
                var clazz = scope.$eval(matches[1]);
                var compareWithExp = matches[2];
                var data = expToData[exp];
                if (!data) {
                    var watchFn = function (compareWithVal) {
                        var newActivated = null;
                        instances.some(function (instance) {
                            var thisVal = instance.scope.$eval(onExp);
                            if (thisVal === compareWithVal) {
                                newActivated = instance;
                                return true;
                            }
                        });
                        if (data.lastActivated !== newActivated) {
                            if (data.lastActivated) {
                                $animate.removeClass(data.lastActivated.element, clazz);
                            }
                            if (newActivated) {
                                $animate.addClass(newActivated.element, clazz);
                            }
                            data.lastActivated = newActivated;
                        }
                    };
                    expToData[exp] = data = {
                        lastActivated: null,
                        scope: scope,
                        watchFn: watchFn,
                        compareWithExp: compareWithExp,
                        watcher: scope.$watch(compareWithExp, watchFn)
                    };
                }
                data.watchFn(scope.$eval(compareWithExp));
            }

            function removeScope(e) {
                var removedScope = e.targetScope;
                var index = linkedScopes.indexOf(removedScope);
                linkedScopes.splice(index, 1);
                instances.splice(index, 1);
                if (linkedScopes.length) {
                    var newWatchScope = linkedScopes[0];
                    angular.forEach(expToData, function (data) {
                        if (data.scope === removedScope) {
                            data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                            data.scope = newWatchScope;
                        }
                    });
                }
                else {
                    expToData = {};
                }
            }
        }
    };
}]);
angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods for working with the DOM.
 * It is meant to be used where we need to absolute-position elements in
 * relation to another element (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$uibPosition', ['$document', '$window', function ($document, $window) {
      /**
       * Used by scrollbarWidth() function to cache scrollbar's width.
       * Do not access this variable directly, use scrollbarWidth() instead.
       */
      var SCROLLBAR_WIDTH;
      var OVERFLOW_REGEX = {
          normal: /(auto|scroll)/,
          hidden: /(auto|scroll|hidden)/
      };
      var PLACEMENT_REGEX = {
          auto: /\s?auto?\s?/i,
          primary: /^(top|bottom|left|right)$/,
          secondary: /^(top|bottom|left|right|center)$/,
          vertical: /^(top|bottom)$/
      };

      return {

          /**
           * Provides a raw DOM element from a jQuery/jQLite element.
           *
           * @param {element} elem - The element to convert.
           *
           * @returns {element} A HTML element.
           */
          getRawNode: function (elem) {
              return elem[0] || elem;
          },

          /**
           * Provides a parsed number for a style property.  Strips
           * units and casts invalid numbers to 0.
           *
           * @param {string} value - The style value to parse.
           *
           * @returns {number} A valid number.
           */
          parseStyle: function (value) {
              value = parseFloat(value);
              return isFinite(value) ? value : 0;
          },

          /**
           * Provides the closest positioned ancestor.
           *
           * @param {element} element - The element to get the offest parent for.
           *
           * @returns {element} The closest positioned ancestor.
           */
          offsetParent: function (elem) {
              elem = this.getRawNode(elem);

              var offsetParent = elem.offsetParent || $document[0].documentElement;

              function isStaticPositioned(el) {
                  return ($window.getComputedStyle(el).position || 'static') === 'static';
              }

              while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
                  offsetParent = offsetParent.offsetParent;
              }

              return offsetParent || $document[0].documentElement;
          },

          /**
           * Provides the scrollbar width, concept from TWBS measureScrollbar()
           * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js
           *
           * @returns {number} The width of the browser scollbar.
           */
          scrollbarWidth: function () {
              if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                  var scrollElem = angular.element('<div style="position: absolute; top: -9999px; width: 50px; height: 50px; overflow: scroll;"></div>');
                  $document.find('body').append(scrollElem);
                  SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
                  SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
                  scrollElem.remove();
              }

              return SCROLLBAR_WIDTH;
          },

          /**
           * Provides the closest scrollable ancestor.
           * A port of the jQuery UI scrollParent method:
           * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js
           *
           * @param {element} elem - The element to find the scroll parent of.
           * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,
           *   default is false.
           *
           * @returns {element} A HTML element.
           */
          scrollParent: function (elem, includeHidden) {
              elem = this.getRawNode(elem);

              var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
              var documentEl = $document[0].documentElement;
              var elemStyle = $window.getComputedStyle(elem);
              var excludeStatic = elemStyle.position === 'absolute';
              var scrollParent = elem.parentElement || documentEl;

              if (scrollParent === documentEl || elemStyle.position === 'fixed') {
                  return documentEl;
              }

              while (scrollParent.parentElement && scrollParent !== documentEl) {
                  var spStyle = $window.getComputedStyle(scrollParent);
                  if (excludeStatic && spStyle.position !== 'static') {
                      excludeStatic = false;
                  }

                  if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
                      break;
                  }
                  scrollParent = scrollParent.parentElement;
              }

              return scrollParent;
          },

          /**
           * Provides read-only equivalent of jQuery's position function:
           * http://api.jquery.com/position/ - distance to closest positioned
           * ancestor.  Does not account for margins by default like jQuery position.
           *
           * @param {element} elem - The element to caclulate the position on.
           * @param {boolean=} [includeMargins=false] - Should margins be accounted
           * for, default is false.
           *
           * @returns {object} An object with the following properties:
           *   <ul>
           *     <li>**width**: the width of the element</li>
           *     <li>**height**: the height of the element</li>
           *     <li>**top**: distance to top edge of offset parent</li>
           *     <li>**left**: distance to left edge of offset parent</li>
           *   </ul>
           */
          position: function (elem, includeMagins) {
              elem = this.getRawNode(elem);

              var elemOffset = this.offset(elem);
              if (includeMagins) {
                  var elemStyle = $window.getComputedStyle(elem);
                  elemOffset.top -= this.parseStyle(elemStyle.marginTop);
                  elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
              }
              var parent = this.offsetParent(elem);
              var parentOffset = { top: 0, left: 0 };

              if (parent !== $document[0].documentElement) {
                  parentOffset = this.offset(parent);
                  parentOffset.top += parent.clientTop - parent.scrollTop;
                  parentOffset.left += parent.clientLeft - parent.scrollLeft;
              }

              return {
                  width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                  height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                  top: Math.round(elemOffset.top - parentOffset.top),
                  left: Math.round(elemOffset.left - parentOffset.left)
              };
          },

          /**
           * Provides read-only equivalent of jQuery's offset function:
           * http://api.jquery.com/offset/ - distance to viewport.  Does
           * not account for borders, margins, or padding on the body
           * element.
           *
           * @param {element} elem - The element to calculate the offset on.
           *
           * @returns {object} An object with the following properties:
           *   <ul>
           *     <li>**width**: the width of the element</li>
           *     <li>**height**: the height of the element</li>
           *     <li>**top**: distance to top edge of viewport</li>
           *     <li>**right**: distance to bottom edge of viewport</li>
           *   </ul>
           */
          offset: function (elem) {
              elem = this.getRawNode(elem);

              var elemBCR = elem.getBoundingClientRect();
              return {
                  width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                  height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                  top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                  left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
              };
          },

          /**
           * Provides offset distance to the closest scrollable ancestor
           * or viewport.  Accounts for border and scrollbar width.
           *
           * Right and bottom dimensions represent the distance to the
           * respective edge of the viewport element.  If the element
           * edge extends beyond the viewport, a negative value will be
           * reported.
           *
           * @param {element} elem - The element to get the viewport offset for.
           * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead
           * of the first scrollable element, default is false.
           * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element
           * be accounted for, default is true.
           *
           * @returns {object} An object with the following properties:
           *   <ul>
           *     <li>**top**: distance to the top content edge of viewport element</li>
           *     <li>**bottom**: distance to the bottom content edge of viewport element</li>
           *     <li>**left**: distance to the left content edge of viewport element</li>
           *     <li>**right**: distance to the right content edge of viewport element</li>
           *   </ul>
           */
          viewportOffset: function (elem, useDocument, includePadding) {
              elem = this.getRawNode(elem);
              includePadding = includePadding !== false ? true : false;

              var elemBCR = elem.getBoundingClientRect();
              var offsetBCR = { top: 0, left: 0, bottom: 0, right: 0 };

              var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
              var offsetParentBCR = offsetParent.getBoundingClientRect();

              offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
              offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
              if (offsetParent === $document[0].documentElement) {
                  offsetBCR.top += $window.pageYOffset;
                  offsetBCR.left += $window.pageXOffset;
              }
              offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
              offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;

              if (includePadding) {
                  var offsetParentStyle = $window.getComputedStyle(offsetParent);
                  offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
                  offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
                  offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
                  offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
              }

              return {
                  top: Math.round(elemBCR.top - offsetBCR.top),
                  bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                  left: Math.round(elemBCR.left - offsetBCR.left),
                  right: Math.round(offsetBCR.right - elemBCR.right)
              };
          },

          /**
           * Provides an array of placement values parsed from a placement string.
           * Along with the 'auto' indicator, supported placement strings are:
           *   <ul>
           *     <li>top: element on top, horizontally centered on host element.</li>
           *     <li>top-left: element on top, left edge aligned with host element left edge.</li>
           *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>
           *     <li>bottom: element on bottom, horizontally centered on host element.</li>
           *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>
           *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>
           *     <li>left: element on left, vertically centered on host element.</li>
           *     <li>left-top: element on left, top edge aligned with host element top edge.</li>
           *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>
           *     <li>right: element on right, vertically centered on host element.</li>
           *     <li>right-top: element on right, top edge aligned with host element top edge.</li>
           *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>
           *   </ul>
           * A placement string with an 'auto' indicator is expected to be
           * space separated from the placement, i.e: 'auto bottom-left'  If
           * the primary and secondary placement values do not match 'top,
           * bottom, left, right' then 'top' will be the primary placement and
           * 'center' will be the secondary placement.  If 'auto' is passed, true
           * will be returned as the 3rd value of the array.
           *
           * @param {string} placement - The placement string to parse.
           *
           * @returns {array} An array with the following values
           * <ul>
           *   <li>**[0]**: The primary placement.</li>
           *   <li>**[1]**: The secondary placement.</li>
           *   <li>**[2]**: If auto is passed: true, else undefined.</li>
           * </ul>
           */
          parsePlacement: function (placement) {
              var autoPlace = PLACEMENT_REGEX.auto.test(placement);
              if (autoPlace) {
                  placement = placement.replace(PLACEMENT_REGEX.auto, '');
              }

              placement = placement.split('-');

              placement[0] = placement[0] || 'top';
              if (!PLACEMENT_REGEX.primary.test(placement[0])) {
                  placement[0] = 'top';
              }

              placement[1] = placement[1] || 'center';
              if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
                  placement[1] = 'center';
              }

              if (autoPlace) {
                  placement[2] = true;
              } else {
                  placement[2] = false;
              }

              return placement;
          },

          /**
           * Provides coordinates for an element to be positioned relative to
           * another element.  Passing 'auto' as part of the placement parameter
           * will enable smart placement - where the element fits. i.e:
           * 'auto left-top' will check to see if there is enough space to the left
           * of the hostElem to fit the targetElem, if not place right (same for secondary
           * top placement).  Available space is calculated using the viewportOffset
           * function.
           *
           * @param {element} hostElem - The element to position against.
           * @param {element} targetElem - The element to position.
           * @param {string=} [placement=top] - The placement for the targetElem,
           *   default is 'top'. 'center' is assumed as secondary placement for
           *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:
           *   <ul>
           *     <li>top</li>
           *     <li>top-right</li>
           *     <li>top-left</li>
           *     <li>bottom</li>
           *     <li>bottom-left</li>
           *     <li>bottom-right</li>
           *     <li>left</li>
           *     <li>left-top</li>
           *     <li>left-bottom</li>
           *     <li>right</li>
           *     <li>right-top</li>
           *     <li>right-bottom</li>
           *   </ul>
           * @param {boolean=} [appendToBody=false] - Should the top and left values returned
           *   be calculated from the body element, default is false.
           *
           * @returns {object} An object with the following properties:
           *   <ul>
           *     <li>**top**: Value for targetElem top.</li>
           *     <li>**left**: Value for targetElem left.</li>
           *     <li>**placement**: The resolved placement.</li>
           *   </ul>
           */
          positionElements: function (hostElem, targetElem, placement, appendToBody) {
              hostElem = this.getRawNode(hostElem);
              targetElem = this.getRawNode(targetElem);

              // need to read from prop to support tests.
              var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
              var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');

              placement = this.parsePlacement(placement);

              var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
              var targetElemPos = { top: 0, left: 0, placement: '' };

              if (placement[2]) {
                  var viewportOffset = this.viewportOffset(hostElem);

                  var targetElemStyle = $window.getComputedStyle(targetElem);
                  var adjustedSize = {
                      width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                      height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                  };

                  placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :
                                 placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :
                                 placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :
                                 placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :
                                 placement[0];

                  placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :
                                 placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :
                                 placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :
                                 placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :
                                 placement[1];

                  if (placement[1] === 'center') {
                      if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                          var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                          if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                              placement[1] = 'left';
                          } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                              placement[1] = 'right';
                          }
                      } else {
                          var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                          if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                              placement[1] = 'top';
                          } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                              placement[1] = 'bottom';
                          }
                      }
                  }
              }

              switch (placement[0]) {
                  case 'top':
                      targetElemPos.top = hostElemPos.top - targetHeight;
                      break;
                  case 'bottom':
                      targetElemPos.top = hostElemPos.top + hostElemPos.height;
                      break;
                  case 'left':
                      targetElemPos.left = hostElemPos.left - targetWidth;
                      break;
                  case 'right':
                      targetElemPos.left = hostElemPos.left + hostElemPos.width;
                      break;
              }

              switch (placement[1]) {
                  case 'top':
                      targetElemPos.top = hostElemPos.top;
                      break;
                  case 'bottom':
                      targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                      break;
                  case 'left':
                      targetElemPos.left = hostElemPos.left;
                      break;
                  case 'right':
                      targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                      break;
                  case 'center':
                      if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                          targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
                      } else {
                          targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
                      }
                      break;
              }

              targetElemPos.top = Math.round(targetElemPos.top);
              targetElemPos.left = Math.round(targetElemPos.left);
              targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];

              return targetElemPos;
          },

          /**
          * Provides a way for positioning tooltip & dropdown
          * arrows when using placement options beyond the standard
          * left, right, top, or bottom.
          *
          * @param {element} elem - The tooltip/dropdown element.
          * @param {string} placement - The placement for the elem.
          */
          positionArrow: function (elem, placement) {
              elem = this.getRawNode(elem);

              var isTooltip = true;

              var innerElem = elem.querySelector('.tooltip-inner');
              if (!innerElem) {
                  isTooltip = false;
                  innerElem = elem.querySelector('.popover-inner');
              }
              if (!innerElem) {
                  return;
              }

              var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
              if (!arrowElem) {
                  return;
              }

              placement = this.parsePlacement(placement);
              if (placement[1] === 'center') {
                  // no adjustment necessary - just reset styles
                  angular.element(arrowElem).css({ top: '', bottom: '', right: '', left: '', margin: '' });
                  return;
              }

              var borderProp = 'border-' + placement[0] + '-width';
              var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];

              var borderRadiusProp = 'border-';
              if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                  borderRadiusProp += placement[0] + '-' + placement[1];
              } else {
                  borderRadiusProp += placement[1] + '-' + placement[0];
              }
              borderRadiusProp += '-radius';
              var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];

              var arrowCss = {
                  top: 'auto',
                  bottom: 'auto',
                  left: 'auto',
                  right: 'auto',
                  margin: 0
              };

              switch (placement[0]) {
                  case 'top':
                      arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
                      break;
                  case 'bottom':
                      arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
                      break;
                  case 'left':
                      arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
                      break;
                  case 'right':
                      arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
                      break;
              }

              arrowCss[placement[1]] = borderRadius;

              angular.element(arrowElem).css(arrowCss);
          }
      };
  }]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.position'])

.value('$datepickerSuppressError', false)

.constant('uibDatepickerConfig', {
    formatDay: 'dd',
    formatMonth: 'MMMM',
    formatYear: 'yyyy',
    formatDayHeader: 'EEE',
    formatDayTitle: 'MMMM yyyy',
    formatMonthTitle: 'yyyy',
    datepickerMode: 'day',
    minMode: 'day',
    maxMode: 'year',
    showWeeks: true,
    startingDay: 0,
    yearRows: 4,
    yearColumns: 5,
    minDate: null,
    maxDate: null,
    shortcutPropagation: false,
    ngModelOptions: {}
})

.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', 'uibDateParser',
  function ($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, dateParser) {
      var self = this,
          ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;
          ngModelOptions = {};

      // Modes chain
      this.modes = ['day', 'month', 'year'];

      // Interpolated configuration attributes
      angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle'], function (key) {
          self[key] = angular.isDefined($attrs[key]) ? $interpolate($attrs[key])($scope.$parent) : datepickerConfig[key];
      });

      // Evaled configuration attributes
      angular.forEach(['showWeeks', 'startingDay', 'yearRows', 'yearColumns', 'shortcutPropagation'], function (key) {
          self[key] = angular.isDefined($attrs[key]) ? $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
      });

      // Watchable date attributes
      angular.forEach(['minDate', 'maxDate'], function (key) {
          if ($attrs[key]) {
              $scope.$parent.$watch($attrs[key], function (value) {
                  self[key] = value ? angular.isDate(value) ? dateParser.fromTimezone(new Date(value), ngModelOptions.timezone) : new Date(dateFilter(value, 'medium')) : null;
                  self.refreshView();
              });
          } else {
              self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
          }
      });

      angular.forEach(['minMode', 'maxMode'], function (key) {
          if ($attrs[key]) {
              $scope.$parent.$watch($attrs[key], function (value) {
                  self[key] = $scope[key] = angular.isDefined(value) ? value : $attrs[key];
                  if (key === 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) ||
                    key === 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) {
                      $scope.datepickerMode = self[key];
                  }
              });
          } else {
              self[key] = $scope[key] = datepickerConfig[key] || null;
          }
      });

      $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
      $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

      if (angular.isDefined($attrs.initDate)) {
          this.activeDate = dateParser.fromTimezone($scope.$parent.$eval($attrs.initDate), ngModelOptions.timezone) || new Date();
          $scope.$parent.$watch($attrs.initDate, function (initDate) {
              if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
                  self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
                  self.refreshView();
              }
          });
      } else {
          this.activeDate = new Date();
      }

      $scope.disabled = angular.isDefined($attrs.disabled) || false;
      if (angular.isDefined($attrs.ngDisabled)) {
          $scope.$parent.$watch($attrs.ngDisabled, function (disabled) {
              $scope.disabled = disabled;
              self.refreshView();
          });
      }

      $scope.isActive = function (dateObject) {
          if (self.compare(dateObject.date, self.activeDate) === 0) {
              $scope.activeDateId = dateObject.uid;
              return true;
          }
          return false;
      };

      this.init = function (ngModelCtrl_) {
          ngModelCtrl = ngModelCtrl_;
          ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;

          if (ngModelCtrl.$modelValue) {
              this.activeDate = ngModelCtrl.$modelValue;
          }

          ngModelCtrl.$render = function () {
              self.render();
          };
      };

      this.render = function () {
          if (ngModelCtrl.$viewValue) {
              var date = new Date(ngModelCtrl.$viewValue),
                  isValid = !isNaN(date);

              if (isValid) {
                  this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
              } else if (!$datepickerSuppressError) {
                  $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
              }
          }
          this.refreshView();
      };

      this.refreshView = function () {
          if (this.element) {
              $scope.selectedDt = null;
              this._refreshView();
              if ($scope.activeDt) {
                  $scope.activeDateId = $scope.activeDt.uid;
              }

              var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
              date = dateParser.fromTimezone(date, ngModelOptions.timezone);
              ngModelCtrl.$setValidity('dateDisabled', !date ||
                this.element && !this.isDisabled(date));
          }
      };

      this.createDateObject = function (date, format) {
          var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
          model = dateParser.fromTimezone(model, ngModelOptions.timezone);
          var dt = {
              date: date,
              label: dateFilter(date, format),
              selected: model && this.compare(date, model) === 0,
              disabled: this.isDisabled(date),
              current: this.compare(date, new Date()) === 0,
              customClass: this.customClass(date) || null
          };

          if (model && this.compare(date, model) === 0) {
              $scope.selectedDt = dt;
          }

          if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
              $scope.activeDt = dt;
          }

          return dt;
      };

      this.isDisabled = function (date) {
          return $scope.disabled ||
            this.minDate && this.compare(date, this.minDate) < 0 ||
            this.maxDate && this.compare(date, this.maxDate) > 0 ||
            $attrs.dateDisabled && $scope.dateDisabled({ date: date, mode: $scope.datepickerMode });
      };

      this.customClass = function (date) {
          return $scope.customClass({ date: date, mode: $scope.datepickerMode });
      };

      // Split array into smaller arrays
      this.split = function (arr, size) {
          var arrays = [];
          while (arr.length > 0) {
              arrays.push(arr.splice(0, size));
          }
          return arrays;
      };

      $scope.wdSelect = function (evt, date) {
          if ($scope.datepickerMode != self.minMode) {
              evt.preventDefault();
              if (!self.shortcutPropagation) {
                  evt.stopPropagation();
              }
          }
          $scope.select(date);
      };

      $scope.select = function (date) {
          if ($scope.datepickerMode === self.minMode) {
              var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
              dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
              dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
              ngModelCtrl.$setViewValue(dt);
              ngModelCtrl.$render();
          } else {
              self.activeDate = date;
              $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
          }
      };

      $scope.move = function (direction) {
          var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
              month = self.activeDate.getMonth() + direction * (self.step.months || 0);
          self.activeDate.setFullYear(year, month, 1);
          self.refreshView();
      };

      $scope.wdToggleMode = function (evt, direction) {
          evt.preventDefault();
          if (!self.shortcutPropagation) {
              evt.stopPropagation();
          }

          $scope.toggleMode(direction);
      };

      $scope.toggleMode = function (direction) {
          direction = direction || 1;

          if ($scope.datepickerMode === self.maxMode && direction === 1 ||
            $scope.datepickerMode === self.minMode && direction === -1) {
              return;
          }

          $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
      };

      // Key event mapper
      $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

      var focusElement = function () {
          self.element[0].focus();
      };

      // Listen for focus requests from popup directive
      $scope.$on('uib:datepicker.focus', focusElement);

      $scope.keydown = function (evt) {
          var key = $scope.keys[evt.which];

          if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
              return;
          }

          evt.preventDefault();
          if (!self.shortcutPropagation) {
              evt.stopPropagation();
          }

          if (key === 'enter' || key === 'space') {
              if (self.isDisabled(self.activeDate)) {
                  return; // do nothing
              }
              $scope.select(self.activeDate);
          } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
              $scope.toggleMode(key === 'up' ? 1 : -1);
          } else {
              self.handleKeyDown(key, evt);
              self.refreshView();
          }
      };
  }])

.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    this.step = { months: 1 };
    this.element = $element;
    function getDaysInMonth(year, month) {
        return month === 1 && year % 4 === 0 &&
          (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
    }

    this.init = function (ctrl) {
        angular.extend(ctrl, this);
        scope.showWeeks = ctrl.showWeeks;
        ctrl.refreshView();
    };

    this.getDates = function (startDate, n) {
        var dates = new Array(n), current = new Date(startDate), i = 0, date;
        while (i < n) {
            date = new Date(current);
            dates[i++] = date;
            current.setDate(current.getDate() + 1);
        }
        return dates;
    };

    this._refreshView = function () {
        var year = this.activeDate.getFullYear(),
          month = this.activeDate.getMonth(),
          firstDayOfMonth = new Date(this.activeDate);

        firstDayOfMonth.setFullYear(year, month, 1);

        var difference = this.startingDay - firstDayOfMonth.getDay(),
          numDisplayedFromPreviousMonth = difference > 0 ?
            7 - difference : -difference,
          firstDate = new Date(firstDayOfMonth);

        if (numDisplayedFromPreviousMonth > 0) {
            firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        }

        // 42 is the number of days on a six-week calendar
        var days = this.getDates(firstDate, 42);
        for (var i = 0; i < 42; i++) {
            days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
                secondary: days[i].getMonth() !== month,
                uid: scope.uniqueId + '-' + i
            });
        }

        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
            scope.labels[j] = {
                abbr: dateFilter(days[j].date, this.formatDayHeader),
                full: dateFilter(days[j].date, 'EEEE')
            };
        }

        scope.title = dateFilter(this.activeDate, this.formatDayTitle);
        scope.rows = this.split(days, 7);

        if (scope.showWeeks) {
            scope.weekNumbers = [];
            var thursdayIndex = (4 + 7 - this.startingDay) % 7,
                numWeeks = scope.rows.length;
            for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
                scope.weekNumbers.push(
                  getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
            }
        }
    };

    this.compare = function (date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
    };

    function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    }

    this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getDate();

        if (key === 'left') {
            date = date - 1;
        } else if (key === 'up') {
            date = date - 7;
        } else if (key === 'right') {
            date = date + 1;
        } else if (key === 'down') {
            date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
            var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
            this.activeDate.setMonth(month, 1);
            date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else if (key === 'home') {
            date = 1;
        } else if (key === 'end') {
            date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
        }
        this.activeDate.setDate(date);
    };
}])

.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
    this.step = { years: 1 };
    this.element = $element;

    this.init = function (ctrl) {
        angular.extend(ctrl, this);
        ctrl.refreshView();
    };

    this._refreshView = function () {
        var months = new Array(12),
            year = this.activeDate.getFullYear(),
            date;

        for (var i = 0; i < 12; i++) {
            date = new Date(this.activeDate);
            date.setFullYear(year, i, 1);
            months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
                uid: scope.uniqueId + '-' + i
            });
        }

        scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
        scope.rows = this.split(months, 3);
    };

    this.compare = function (date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth());
        var _date2 = new Date(date2.getFullYear(), date2.getMonth());
        _date1.setFullYear(date1.getFullYear());
        _date2.setFullYear(date2.getFullYear());
        return _date1 - _date2;
    };

    this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getMonth();

        if (key === 'left') {
            date = date - 1;
        } else if (key === 'up') {
            date = date - 3;
        } else if (key === 'right') {
            date = date + 1;
        } else if (key === 'down') {
            date = date + 3;
        } else if (key === 'pageup' || key === 'pagedown') {
            var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
            this.activeDate.setFullYear(year);
        } else if (key === 'home') {
            date = 0;
        } else if (key === 'end') {
            date = 11;
        }
        this.activeDate.setMonth(date);
    };
}])

.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function (scope, $element, dateFilter) {
    var columns, range;
    this.element = $element;

    function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
    }

    this.yearpickerInit = function () {
        columns = this.yearColumns;
        range = this.yearRows * columns;
        this.step = { years: range };
    };

    this._refreshView = function () {
        var years = new Array(range), date;

        for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()) ; i < range; i++) {
            date = new Date(this.activeDate);
            date.setFullYear(start + i, 0, 1);
            years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
                uid: scope.uniqueId + '-' + i
            });
        }

        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = this.split(years, columns);
        scope.columns = columns;
    };

    this.compare = function (date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
    };

    this.handleKeyDown = function (key, evt) {
        var date = this.activeDate.getFullYear();

        if (key === 'left') {
            date = date - 1;
        } else if (key === 'up') {
            date = date - columns;
        } else if (key === 'right') {
            date = date + 1;
        } else if (key === 'down') {
            date = date + columns;
        } else if (key === 'pageup' || key === 'pagedown') {
            date += (key === 'pageup' ? -1 : 1) * range;
        } else if (key === 'home') {
            date = getStartingYear(this.activeDate.getFullYear());
        } else if (key === 'end') {
            date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
        }
        this.activeDate.setFullYear(date);
    };
}])

.directive('uibDatepicker', function () {
    return {
        replace: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'template/datepicker/datepicker.html';
        },
        scope: {
            datepickerMode: '=?',
            dateDisabled: '&',
            customClass: '&',
            shortcutPropagation: '&?'
        },
        require: ['uibDatepicker', '^ngModel'],
        controller: 'UibDatepickerController',
        controllerAs: 'datepicker',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

            datepickerCtrl.init(ngModelCtrl);
        }
    };
})

.directive('uibDaypicker', function () {
    return {
        replace: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'template/datepicker/day.html';
        },
        require: ['^uibDatepicker', 'uibDaypicker'],
        controller: 'UibDaypickerController',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0],
              daypickerCtrl = ctrls[1];

            daypickerCtrl.init(datepickerCtrl);
        }
    };
})

.directive('uibMonthpicker', function () {
    return {
        replace: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'template/datepicker/month.html';
        },
        require: ['^uibDatepicker', 'uibMonthpicker'],
        controller: 'UibMonthpickerController',
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0],
              monthpickerCtrl = ctrls[1];

            monthpickerCtrl.init(datepickerCtrl);
        }
    };
})

.directive('uibYearpicker', function () {
    return {
        replace: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'template/datepicker/year.html';
        },
        require: ['^uibDatepicker', 'uibYearpicker'],
        controller: 'UibYearpickerController',
        link: function (scope, element, attrs, ctrls) {
            var ctrl = ctrls[0];
            angular.extend(ctrl, ctrls[1]);
            ctrl.yearpickerInit();

            ctrl.refreshView();
        }
    };
})

.constant('uibDatepickerPopupConfig', {
    datepickerPopup: 'yyyy-MM-dd',
    datepickerPopupTemplateUrl: 'template/datepicker/popup.html',
    datepickerTemplateUrl: 'template/datepicker/datepicker.html',
    html5Types: {
        date: 'yyyy-MM-dd',
        'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
        'month': 'yyyy-MM'
    },
    currentText: 'Today',
    clearText: 'Clear',
    closeText: 'Done',
    closeOnDateSelection: true,
    appendToBody: false,
    showButtonBar: true,
    onOpenFocus: true,
    altInputFormats: []
})

.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig',
function (scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig) {
    var self = this;
    var cache = {},
      isHtml5DateInput = false;
    var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
      datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,
      ngModel, ngModelOptions, $popup, altInputFormats;

    scope.watchData = {};

    this.init = function (_ngModel_) {
        ngModel = _ngModel_;
        ngModelOptions = _ngModel_.$options || datepickerConfig.ngModelOptions;
        closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
        appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
        onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
        datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
        datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
        altInputFormats = angular.isDefined(attrs.altInputFormats) ? scope.$parent.$eval(attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;

        scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

        if (datepickerPopupConfig.html5Types[attrs.type]) {
            dateFormat = datepickerPopupConfig.html5Types[attrs.type];
            isHtml5DateInput = true;
        } else {
            dateFormat = attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
            attrs.$observe('uibDatepickerPopup', function (value, oldValue) {
                var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
                // Invalidate the $modelValue to ensure that formatters re-run
                // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
                if (newDateFormat !== dateFormat) {
                    dateFormat = newDateFormat;
                    ngModel.$modelValue = null;

                    if (!dateFormat) {
                        throw new Error('uibDatepickerPopup must have a date format specified.');
                    }
                }
            });
        }

        if (!dateFormat) {
            throw new Error('uibDatepickerPopup must have a date format specified.');
        }

        if (isHtml5DateInput && attrs.uibDatepickerPopup) {
            throw new Error('HTML5 date input types do not support custom formats.');
        }

        // popup element used to display calendar
        popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
        scope.ngModelOptions = angular.copy(ngModelOptions);
        scope.ngModelOptions.timezone = null;
        popupEl.attr({
            'ng-model': 'date',
            'ng-model-options': 'ngModelOptions',
            'ng-change': 'dateSelection(date)',
            'template-url': datepickerPopupTemplateUrl
        });

        // datepicker element
        datepickerEl = angular.element(popupEl.children()[0]);
        datepickerEl.attr('template-url', datepickerTemplateUrl);

        if (isHtml5DateInput) {
            if (attrs.type === 'month') {
                datepickerEl.attr('datepicker-mode', '"month"');
                datepickerEl.attr('min-mode', 'month');
            }
        }

        if (attrs.datepickerOptions) {
            var options = scope.$parent.$eval(attrs.datepickerOptions);
            if (options && options.initDate) {
                scope.initDate = dateParser.fromTimezone(options.initDate, ngModelOptions.timezone);
                datepickerEl.attr('init-date', 'initDate');
                delete options.initDate;
            }
            angular.forEach(options, function (value, option) {
                datepickerEl.attr(cameltoDash(option), value);
            });
        }

        angular.forEach(['minMode', 'maxMode'], function (key) {
            if (attrs[key]) {
                scope.$parent.$watch(function () { return attrs[key]; }, function (value) {
                    scope.watchData[key] = value;
                });
                datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
            }
        });

        angular.forEach(['datepickerMode', 'shortcutPropagation'], function (key) {
            if (attrs[key]) {
                var getAttribute = $parse(attrs[key]);
                var propConfig = {
                    get: function () {
                        return getAttribute(scope.$parent);
                    }
                };

                datepickerEl.attr(cameltoDash(key), 'watchData.' + key);

                // Propagate changes from datepicker to outside
                if (key === 'datepickerMode') {
                    var setAttribute = getAttribute.assign;
                    propConfig.set = function (v) {
                        setAttribute(scope.$parent, v);
                    };
                }

                Object.defineProperty(scope.watchData, key, propConfig);
            }
        });

        angular.forEach(['minDate', 'maxDate', 'initDate'], function (key) {
            if (attrs[key]) {
                var getAttribute = $parse(attrs[key]);

                scope.$parent.$watch(getAttribute, function (value) {
                    if (key === 'minDate' || key === 'maxDate') {
                        cache[key] = angular.isDate(value) ? dateParser.fromTimezone(new Date(value), ngModelOptions.timezone) : new Date(dateFilter(value, 'medium'));
                    }

                    scope.watchData[key] = cache[key] || dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                });

                datepickerEl.attr(cameltoDash(key), 'watchData.' + key);
            }
        });

        if (attrs.dateDisabled) {
            datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
        }

        angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle', 'showWeeks', 'startingDay', 'yearRows', 'yearColumns'], function (key) {
            if (angular.isDefined(attrs[key])) {
                datepickerEl.attr(cameltoDash(key), attrs[key]);
            }
        });

        if (attrs.customClass) {
            datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
        }

        if (!isHtml5DateInput) {
            // Internal API to maintain the correct ng-invalid-[key] class
            ngModel.$$parserName = 'date';
            ngModel.$validators.date = validator;
            ngModel.$parsers.unshift(parseDate);
            ngModel.$formatters.push(function (value) {
                if (ngModel.$isEmpty(value)) {
                    scope.date = value;
                    return value;
                }
                scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
                return dateFilter(scope.date, dateFormat);
            });
        } else {
            ngModel.$formatters.push(function (value) {
                scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone);
                return value;
            });
        }

        // Detect changes in the view from the text box
        ngModel.$viewChangeListeners.push(function () {
            scope.date = parseDateString(ngModel.$viewValue);
        });

        element.bind('keydown', inputKeydownBind);

        $popup = $compile(popupEl)(scope);
        // Prevent jQuery cache memory leak (template is now redundant after linking)
        popupEl.remove();

        if (appendToBody) {
            $document.find('body').append($popup);
        } else {
            element.after($popup);
        }

        scope.$on('$destroy', function () {
            if (scope.isOpen === true) {
                if (!$rootScope.$$phase) {
                    scope.$apply(function () {
                        scope.isOpen = false;
                    });
                }
            }

            $popup.remove();
            element.unbind('keydown', inputKeydownBind);
            $document.unbind('click', documentClickBind);
        });
    };

    scope.getText = function (key) {
        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
    };

    scope.isDisabled = function (date) {
        if (date === 'today') {
            date = new Date();
        }

        return scope.watchData.minDate && scope.compare(date, cache.minDate) < 0 ||
          scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0;
    };

    scope.compare = function (date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    };

    // Inner change
    scope.dateSelection = function (dt) {
        if (angular.isDefined(dt)) {
            scope.date = dt;
        }
        var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
        element.val(date);
        ngModel.$setViewValue(date);

        if (closeOnDateSelection) {
            scope.isOpen = false;
            element[0].focus();
        }
    };

    scope.keydown = function (evt) {
        if (evt.which === 27) {
            evt.stopPropagation();
            scope.isOpen = false;
            element[0].focus();
        }
    };

    scope.select = function (date) {
        if (date === 'today') {
            var today = new Date();
            if (angular.isDate(scope.date)) {
                date = new Date(scope.date);
                date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
            } else {
                date = new Date(today.setHours(0, 0, 0, 0));
            }
        }
        scope.dateSelection(date);
    };

    scope.close = function () {
        scope.isOpen = false;
        element[0].focus();
    };

    scope.disabled = angular.isDefined(attrs.disabled) || false;
    if (attrs.ngDisabled) {
        scope.$parent.$watch($parse(attrs.ngDisabled), function (disabled) {
            scope.disabled = disabled;
        });
    }

    scope.$watch('isOpen', function (value) {
        if (value) {
            if (!scope.disabled) {
                scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                scope.position.top = scope.position.top + element.prop('offsetHeight');

                $timeout(function () {
                    if (onOpenFocus) {
                        scope.$broadcast('uib:datepicker.focus');
                    }
                    $document.bind('click', documentClickBind);
                }, 0, false);
            } else {
                scope.isOpen = false;
            }
        } else {
            $document.unbind('click', documentClickBind);
        }
    });

    function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); });
    }

    function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, scope.date);
        if (isNaN(date)) {
            for (var i = 0; i < altInputFormats.length; i++) {
                date = dateParser.parse(viewValue, altInputFormats[i], scope.date);
                if (!isNaN(date)) {
                    return date;
                }
            }
        }
        return date;
    }

    function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
            // presumably timestamp to date object
            viewValue = new Date(viewValue);
        }

        if (!viewValue) {
            return null;
        }

        if (angular.isDate(viewValue) && !isNaN(viewValue)) {
            return viewValue;
        }

        if (angular.isString(viewValue)) {
            var date = parseDateString(viewValue);
            if (!isNaN(date)) {
                return dateParser.toTimezone(date, ngModelOptions.timezone);
            }
        }

        return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
    }

    function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;

        if (!attrs.ngRequired && !value) {
            return true;
        }

        if (angular.isNumber(value)) {
            value = new Date(value);
        }

        if (!value) {
            return true;
        }

        if (angular.isDate(value) && !isNaN(value)) {
            return true;
        }

        if (angular.isString(value)) {
            return !isNaN(parseDateString(viewValue));
        }

        return false;
    }

    function documentClickBind(event) {
        if (!scope.isOpen && scope.disabled) {
            return;
        }

        var popup = $popup[0];
        var dpContainsTarget = element[0].contains(event.target);
        // The popup node may not be an element node
        // In some browsers (IE) only element nodes have the 'contains' function
        var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
        if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
            scope.$apply(function () {
                scope.isOpen = false;
            });
        }
    }

    function inputKeydownBind(evt) {
        if (evt.which === 27 && scope.isOpen) {
            evt.preventDefault();
            evt.stopPropagation();
            scope.$apply(function () {
                scope.isOpen = false;
            });
            element[0].focus();
        } else if (evt.which === 40 && !scope.isOpen) {
            evt.preventDefault();
            evt.stopPropagation();
            scope.$apply(function () {
                scope.isOpen = true;
            });
        }
    }
}])

.directive('uibDatepickerPopup', function () {
    return {
        require: ['ngModel', 'uibDatepickerPopup'],
        controller: 'UibDatepickerPopupController',
        scope: {
            isOpen: '=?',
            currentText: '@',
            clearText: '@',
            closeText: '@',
            dateDisabled: '&',
            customClass: '&'
        },
        link: function (scope, element, attrs, ctrls) {
            var ngModel = ctrls[0],
              ctrl = ctrls[1];

            ctrl.init(ngModel);
        }
    };
})

.directive('uibDatepickerPopupWrap', function () {
    return {
        replace: true,
        transclude: true,
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'template/datepicker/popup.html';
        }
    };
});

angular.module('ui.bootstrap.debounce', [])
/**
 * A helper, internal service that debounces a function
 */
  .factory('$$debounce', ['$timeout', function ($timeout) {
      return function (callback, debounceTime) {
          var timeoutPromise;

          return function () {
              var self = this;
              var args = Array.prototype.slice.call(arguments);
              if (timeoutPromise) {
                  $timeout.cancel(timeoutPromise);
              }

              timeoutPromise = $timeout(function () {
                  callback.apply(self, args);
              }, debounceTime);
          };
      };
  }]);

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])

.constant('uibDropdownConfig', {
    appendToOpenClass: 'uib-dropdown-open',
    openClass: 'open'
})

.service('uibDropdownService', ['$document', '$rootScope', function ($document, $rootScope) {
    var openScope = null;

    this.open = function (dropdownScope) {
        if (!openScope) {
            $document.on('click', closeDropdown);
            $document.on('keydown', keybindFilter);
        }

        if (openScope && openScope !== dropdownScope) {
            openScope.isOpen = false;
        }

        openScope = dropdownScope;
    };

    this.close = function (dropdownScope) {
        if (openScope === dropdownScope) {
            openScope = null;
            $document.off('click', closeDropdown);
            $document.off('keydown', keybindFilter);
        }
    };

    var closeDropdown = function (evt) {
        // This method may still be called during the same mouse event that
        // unbound this event handler. So check openScope before proceeding.
        if (!openScope) { return; }

        if (evt && openScope.getAutoClose() === 'disabled') { return; }

        if (evt && evt.which === 3) { return; }

        var toggleElement = openScope.getToggleElement();
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
            return;
        }

        var dropdownElement = openScope.getDropdownElement();
        if (evt && openScope.getAutoClose() === 'outsideClick' &&
          dropdownElement && dropdownElement[0].contains(evt.target)) {
            return;
        }

        openScope.isOpen = false;

        if (!$rootScope.$$phase) {
            openScope.$apply();
        }
    };

    var keybindFilter = function (evt) {
        if (evt.which === 27) {
            openScope.focusToggleElement();
            closeDropdown();
        } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {
            evt.preventDefault();
            evt.stopPropagation();
            openScope.focusDropdownEntry(evt.which);
        }
    };
}])

.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function ($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    var self = this,
      scope = $scope.$new(), // create a child scope so we are not polluting original one
      templateScope,
      appendToOpenClass = dropdownConfig.appendToOpenClass,
      openClass = dropdownConfig.openClass,
      getIsOpen,
      setIsOpen = angular.noop,
      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
      appendToBody = false,
      appendTo = null,
      keynavEnabled = false,
      selectedOption = null,
      body = $document.find('body');

    $element.addClass('dropdown');

    this.init = function () {
        if ($attrs.isOpen) {
            getIsOpen = $parse($attrs.isOpen);
            setIsOpen = getIsOpen.assign;

            $scope.$watch(getIsOpen, function (value) {
                scope.isOpen = !!value;
            });
        }

        if (angular.isDefined($attrs.dropdownAppendTo)) {
            var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
            if (appendToEl) {
                appendTo = angular.element(appendToEl);
            }
        }

        appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
        keynavEnabled = angular.isDefined($attrs.keyboardNav);

        if (appendToBody && !appendTo) {
            appendTo = body;
        }

        if (appendTo && self.dropdownMenu) {
            appendTo.append(self.dropdownMenu);
            $element.on('$destroy', function handleDestroyEvent() {
                self.dropdownMenu.remove();
            });
        }
    };

    this.toggle = function (open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    };

    // Allow other directives to watch status
    this.isOpen = function () {
        return scope.isOpen;
    };

    scope.getToggleElement = function () {
        return self.toggleElement;
    };

    scope.getAutoClose = function () {
        return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
    };

    scope.getElement = function () {
        return $element;
    };

    scope.isKeynavEnabled = function () {
        return keynavEnabled;
    };

    scope.focusDropdownEntry = function (keyCode) {
        var elems = self.dropdownMenu ? //If append to body is used.
          angular.element(self.dropdownMenu).find('a') :
          $element.find('ul').eq(0).find('a');

        switch (keyCode) {
            case 40: {
                if (!angular.isNumber(self.selectedOption)) {
                    self.selectedOption = 0;
                } else {
                    self.selectedOption = self.selectedOption === elems.length - 1 ?
                      self.selectedOption :
                      self.selectedOption + 1;
                }
                break;
            }
            case 38: {
                if (!angular.isNumber(self.selectedOption)) {
                    self.selectedOption = elems.length - 1;
                } else {
                    self.selectedOption = self.selectedOption === 0 ?
                      0 : self.selectedOption - 1;
                }
                break;
            }
        }
        elems[self.selectedOption].focus();
    };

    scope.getDropdownElement = function () {
        return self.dropdownMenu;
    };

    scope.focusToggleElement = function () {
        if (self.toggleElement) {
            self.toggleElement[0].focus();
        }
    };

    scope.$watch('isOpen', function (isOpen, wasOpen) {
        if (appendTo && self.dropdownMenu) {
            var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),
              css,
              rightalign;

            css = {
                top: pos.top + 'px',
                display: isOpen ? 'block' : 'none'
            };

            rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
            if (!rightalign) {
                css.left = pos.left + 'px';
                css.right = 'auto';
            } else {
                css.left = 'auto';
                css.right = window.innerWidth -
                  (pos.left + $element.prop('offsetWidth')) + 'px';
            }

            // Need to adjust our positioning to be relative to the appendTo container
            // if it's not the body element
            if (!appendToBody) {
                var appendOffset = $position.offset(appendTo);

                css.top = pos.top - appendOffset.top + 'px';

                if (!rightalign) {
                    css.left = pos.left - appendOffset.left + 'px';
                } else {
                    css.right = window.innerWidth -
                      (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
                }
            }

            self.dropdownMenu.css(css);
        }

        var openContainer = appendTo ? appendTo : $element;

        $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function () {
            if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
                toggleInvoker($scope, { open: !!isOpen });
            }
        });

        if (isOpen) {
            if (self.dropdownMenuTemplateUrl) {
                $templateRequest(self.dropdownMenuTemplateUrl).then(function (tplContent) {
                    templateScope = scope.$new();
                    $compile(tplContent.trim())(templateScope, function (dropdownElement) {
                        var newEl = dropdownElement;
                        self.dropdownMenu.replaceWith(newEl);
                        self.dropdownMenu = newEl;
                    });
                });
            }

            scope.focusToggleElement();
            uibDropdownService.open(scope);
        } else {
            if (self.dropdownMenuTemplateUrl) {
                if (templateScope) {
                    templateScope.$destroy();
                }
                var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                self.dropdownMenu.replaceWith(newEl);
                self.dropdownMenu = newEl;
            }

            uibDropdownService.close(scope);
            self.selectedOption = null;
        }

        if (angular.isFunction(setIsOpen)) {
            setIsOpen($scope, isOpen);
        }
    });

    $scope.$on('$locationChangeSuccess', function () {
        if (scope.getAutoClose() !== 'disabled') {
            scope.isOpen = false;
        }
    });
}])

.directive('uibDropdown', function () {
    return {
        controller: 'UibDropdownController',
        link: function (scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init();
        }
    };
})

.directive('uibDropdownMenu', function () {
    return {
        restrict: 'A',
        require: '?^uibDropdown',
        link: function (scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
                return;
            }

            element.addClass('dropdown-menu');

            var tplUrl = attrs.templateUrl;
            if (tplUrl) {
                dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
            }

            if (!dropdownCtrl.dropdownMenu) {
                dropdownCtrl.dropdownMenu = element;
            }
        }
    };
})

.directive('uibDropdownToggle', function () {
    return {
        require: '?^uibDropdown',
        link: function (scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl) {
                return;
            }

            element.addClass('dropdown-toggle');

            dropdownCtrl.toggleElement = element;

            var toggleDropdown = function (event) {
                event.preventDefault();

                if (!element.hasClass('disabled') && !attrs.disabled) {
                    scope.$apply(function () {
                        dropdownCtrl.toggle();
                    });
                }
            };

            element.bind('click', toggleDropdown);

            // WAI-ARIA
            element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
            scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
                element.attr('aria-expanded', !!isOpen);
            });

            scope.$on('$destroy', function () {
                element.unbind('click', toggleDropdown);
            });
        }
    };
});

angular.module('ui.bootstrap.stackedMap', [])
/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function () {
      return {
          createNew: function () {
              var stack = [];

              return {
                  add: function (key, value) {
                      stack.push({
                          key: key,
                          value: value
                      });
                  },
                  get: function (key) {
                      for (var i = 0; i < stack.length; i++) {
                          if (key === stack[i].key) {
                              return stack[i];
                          }
                      }
                  },
                  keys: function () {
                      var keys = [];
                      for (var i = 0; i < stack.length; i++) {
                          keys.push(stack[i].key);
                      }
                      return keys;
                  },
                  top: function () {
                      return stack[stack.length - 1];
                  },
                  remove: function (key) {
                      var idx = -1;
                      for (var i = 0; i < stack.length; i++) {
                          if (key === stack[i].key) {
                              idx = i;
                              break;
                          }
                      }
                      return stack.splice(idx, 1)[0];
                  },
                  removeTop: function () {
                      return stack.splice(stack.length - 1, 1)[0];
                  },
                  length: function () {
                      return stack.length;
                  }
              };
          }
      };
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])
/**
 * A helper, internal data structure that stores all references attached to key
 */
  .factory('$$multiMap', function () {
      return {
          createNew: function () {
              var map = {};

              return {
                  entries: function () {
                      return Object.keys(map).map(function (key) {
                          return {
                              key: key,
                              value: map[key]
                          };
                      });
                  },
                  get: function (key) {
                      return map[key];
                  },
                  hasKey: function (key) {
                      return !!map[key];
                  },
                  keys: function () {
                      return Object.keys(map);
                  },
                  put: function (key, value) {
                      if (!map[key]) {
                          map[key] = [];
                      }

                      map[key].push(value);
                  },
                  remove: function (key, value) {
                      var values = map[key];

                      if (!values) {
                          return;
                      }

                      var idx = values.indexOf(value);

                      if (idx !== -1) {
                          values.splice(idx, 1);
                      }

                      if (!values.length) {
                          delete map[key];
                      }
                  }
              };
          }
      };
  })

/**
 * Pluggable resolve mechanism for the modal resolve resolution
 * Supports UI Router's $resolve service
 */
  .provider('$uibResolve', function () {
      var resolve = this;
      this.resolver = null;

      this.setResolver = function (resolver) {
          this.resolver = resolver;
      };

      this.$get = ['$injector', '$q', function ($injector, $q) {
          var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
          return {
              resolve: function (invocables, locals, parent, self) {
                  if (resolver) {
                      return resolver.resolve(invocables, locals, parent, self);
                  }

                  var promises = [];

                  angular.forEach(invocables, function (value) {
                      if (angular.isFunction(value) || angular.isArray(value)) {
                          promises.push($q.resolve($injector.invoke(value)));
                      } else if (angular.isString(value)) {
                          promises.push($q.resolve($injector.get(value)));
                      } else {
                          promises.push($q.resolve(value));
                      }
                  });

                  return $q.all(promises).then(function (resolves) {
                      var resolveObj = {};
                      var resolveIter = 0;
                      angular.forEach(invocables, function (value, key) {
                          resolveObj[key] = resolves[resolveIter++];
                      });

                      return resolveObj;
                  });
              }
          };
      }];
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('uibModalBackdrop', ['$animateCss', '$injector', '$uibModalStack',
  function ($animateCss, $injector, $modalStack) {
      return {
          replace: true,
          templateUrl: 'uib/template/modal/backdrop.html',
          compile: function (tElement, tAttrs) {
              tElement.addClass(tAttrs.backdropClass);
              return linkFn;
          }
      };

      function linkFn(scope, element, attrs) {
          if (attrs.modalInClass) {
              $animateCss(element, {
                  addClass: attrs.modalInClass
              }).start();

              scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                  var done = setIsAsync();
                  if (scope.modalOptions.animation) {
                      $animateCss(element, {
                          removeClass: attrs.modalInClass
                      }).start().then(done);
                  } else {
                      done();
                  }
              });
          }
      }
  }])

  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animate', '$animateCss', '$document',
  function ($modalStack, $q, $animate, $animateCss, $document) {
      return {
          scope: {
              index: '@'
          },
          replace: true,
          transclude: true,
          templateUrl: function (tElement, tAttrs) {
              return tAttrs.templateUrl || 'uib/template/modal/window.html';
          },
          link: function (scope, element, attrs) {
              element.addClass(attrs.windowClass || '');
              element.addClass(attrs.windowTopClass || '');
              scope.size = attrs.size;

              scope.close = function (evt) {
                  var modal = $modalStack.getTop();
                  if (modal && modal.value.backdrop &&
                    modal.value.backdrop !== 'static' &&
                    evt.target === evt.currentTarget) {
                      evt.preventDefault();
                      evt.stopPropagation();
                      $modalStack.dismiss(modal.key, 'backdrop click');
                  }
              };

              // moved from template to fix issue #2280
              element.on('click', scope.close);

              // This property is only added to the scope for the purpose of detecting when this directive is rendered.
              // We can detect that by using this property in the template associated with this directive and then use
              // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
              scope.$isRendered = true;

              // Deferred object that will be resolved when this modal is render.
              var modalRenderDeferObj = $q.defer();
              // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
              // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
              attrs.$observe('modalRender', function (value) {
                  if (value === 'true') {
                      modalRenderDeferObj.resolve();
                  }
              });

              modalRenderDeferObj.promise.then(function () {
                  var animationPromise = null;

                  if (attrs.modalInClass) {
                      animationPromise = $animateCss(element, {
                          addClass: attrs.modalInClass
                      }).start();

                      scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                          var done = setIsAsync();
                          if ($animateCss) {
                              $animateCss(element, {
                                  removeClass: attrs.modalInClass
                              }).start().then(done);
                          } else {
                              $animate.removeClass(element, attrs.modalInClass).then(done);
                          }
                      });
                  }


                  $q.when(animationPromise).then(function () {
                      /**
                       * If something within the freshly-opened modal already has focus (perhaps via a
                       * directive that causes focus). then no need to try and focus anything.
                       */
                      if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                          var inputWithAutofocus = element[0].querySelector('[autofocus]');
                          /**
                           * Auto-focusing of a freshly-opened modal element causes any child elements
                           * with the autofocus attribute to lose focus. This is an issue on touch
                           * based devices which will show and then hide the onscreen keyboard.
                           * Attempts to refocus the autofocus element via JavaScript will not reopen
                           * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
                           * the modal element if the modal does not contain an autofocus element.
                           */
                          if (inputWithAutofocus) {
                              inputWithAutofocus.focus();
                          } else {
                              element[0].focus();
                          }
                      }
                  });

                  // Notify {@link $modalStack} that modal is rendered.
                  var modal = $modalStack.getTop();
                  if (modal) {
                      $modalStack.modalRendered(modal.key);
                  }
              });
          }
      };
  }])

  .directive('uibModalAnimationClass', function () {
      return {
          compile: function (tElement, tAttrs) {
              if (tAttrs.modalAnimation) {
                  tElement.addClass(tAttrs.uibModalAnimationClass);
              }
          }
      };
  })

  .directive('uibModalTransclude', function () {
      return {
          link: function (scope, element, attrs, controller, transclude) {
              transclude(scope.$parent, function (clone) {
                  element.empty();
                  element.append(clone);
              });
          }
      };
  })

  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',
    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap',
    function ($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap) {
        var OPENED_MODAL_CLASS = 'modal-open';

        var backdropDomEl, backdropScope;
        var openedWindows = $$stackedMap.createNew();
        var openedClasses = $$multiMap.createNew();
        var $modalStack = {
            NOW_CLOSING_EVENT: 'modal.stack.now-closing'
        };

        //Modal focus behavior
        var focusableElementList;
        var focusIndex = 0;
        var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +
          'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
          'iframe, object, embed, *[tabindex], *[contenteditable=true]';

        function backdropIndex() {
            var topBackdropIndex = -1;
            var opened = openedWindows.keys();
            for (var i = 0; i < opened.length; i++) {
                if (openedWindows.get(opened[i]).value.backdrop) {
                    topBackdropIndex = i;
                }
            }
            return topBackdropIndex;
        }

        $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
            if (backdropScope) {
                backdropScope.index = newBackdropIndex;
            }
        });

        function removeModalWindow(modalInstance, elementToReceiveFocus) {
            var modalWindow = openedWindows.get(modalInstance).value;
            var appendToElement = modalWindow.appendTo;

            //clean up the stack
            openedWindows.remove(modalInstance);

            removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function () {
                var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
                openedClasses.remove(modalBodyClass, modalInstance);
                appendToElement.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
                toggleTopWindowClass(true);
            });
            checkRemoveBackdrop();

            //move focus to specified element if available, or else to body
            if (elementToReceiveFocus && elementToReceiveFocus.focus) {
                elementToReceiveFocus.focus();
            } else if (appendToElement.focus) {
                appendToElement.focus();
            }
        }

        // Add or remove "windowTopClass" from the top window in the stack
        function toggleTopWindowClass(toggleSwitch) {
            var modalWindow;

            if (openedWindows.length() > 0) {
                modalWindow = openedWindows.top().value;
                modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
            }
        }

        function checkRemoveBackdrop() {
            //remove backdrop if no longer needed
            if (backdropDomEl && backdropIndex() === -1) {
                var backdropScopeRef = backdropScope;
                removeAfterAnimate(backdropDomEl, backdropScope, function () {
                    backdropScopeRef = null;
                });
                backdropDomEl = undefined;
                backdropScope = undefined;
            }
        }

        function removeAfterAnimate(domEl, scope, done, closedDeferred) {
            var asyncDeferred;
            var asyncPromise = null;
            var setIsAsync = function () {
                if (!asyncDeferred) {
                    asyncDeferred = $q.defer();
                    asyncPromise = asyncDeferred.promise;
                }

                return function asyncDone() {
                    asyncDeferred.resolve();
                };
            };
            scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

            // Note that it's intentional that asyncPromise might be null.
            // That's when setIsAsync has not been called during the
            // NOW_CLOSING_EVENT broadcast.
            return $q.when(asyncPromise).then(afterAnimating);

            function afterAnimating() {
                if (afterAnimating.done) {
                    return;
                }
                afterAnimating.done = true;

                $animateCss(domEl, {
                    event: 'leave'
                }).start().then(function () {
                    domEl.remove();
                    if (closedDeferred) {
                        closedDeferred.resolve();
                    }
                });

                scope.$destroy();
                if (done) {
                    done();
                }
            }
        }

        $document.on('keydown', keydownListener);

        $rootScope.$on('$destroy', function () {
            $document.off('keydown', keydownListener);
        });

        function keydownListener(evt) {
            if (evt.isDefaultPrevented()) {
                return evt;
            }

            var modal = openedWindows.top();
            if (modal) {
                switch (evt.which) {
                    case 27: {
                        if (modal.value.keyboard) {
                            evt.preventDefault();
                            $rootScope.$apply(function () {
                                $modalStack.dismiss(modal.key, 'escape key press');
                            });
                        }
                        break;
                    }
                    case 9: {
                        $modalStack.loadFocusElementList(modal);
                        var focusChanged = false;
                        if (evt.shiftKey) {
                            if ($modalStack.isFocusInFirstItem(evt)) {
                                focusChanged = $modalStack.focusLastFocusableElement();
                            }
                        } else {
                            if ($modalStack.isFocusInLastItem(evt)) {
                                focusChanged = $modalStack.focusFirstFocusableElement();
                            }
                        }

                        if (focusChanged) {
                            evt.preventDefault();
                            evt.stopPropagation();
                        }
                        break;
                    }
                }
            }
        }

        $modalStack.open = function (modalInstance, modal) {
            var modalOpener = $document[0].activeElement,
              modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

            toggleTopWindowClass(false);

            openedWindows.add(modalInstance, {
                deferred: modal.deferred,
                renderDeferred: modal.renderDeferred,
                closedDeferred: modal.closedDeferred,
                modalScope: modal.scope,
                backdrop: modal.backdrop,
                keyboard: modal.keyboard,
                openedClass: modal.openedClass,
                windowTopClass: modal.windowTopClass,
                animation: modal.animation,
                appendTo: modal.appendTo
            });

            openedClasses.put(modalBodyClass, modalInstance);

            var appendToElement = modal.appendTo,
                currBackdropIndex = backdropIndex();

            if (!appendToElement.length) {
                throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
            }

            if (currBackdropIndex >= 0 && !backdropDomEl) {
                backdropScope = $rootScope.$new(true);
                backdropScope.modalOptions = modal;
                backdropScope.index = currBackdropIndex;
                backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
                backdropDomEl.attr('backdrop-class', modal.backdropClass);
                if (modal.animation) {
                    backdropDomEl.attr('modal-animation', 'true');
                }
                $compile(backdropDomEl)(backdropScope);
                $animate.enter(backdropDomEl, appendToElement);
            }

            var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
            angularDomEl.attr({
                'template-url': modal.windowTemplateUrl,
                'window-class': modal.windowClass,
                'window-top-class': modal.windowTopClass,
                'size': modal.size,
                'index': openedWindows.length() - 1,
                'animate': 'animate'
            }).html(modal.content);
            if (modal.animation) {
                angularDomEl.attr('modal-animation', 'true');
            }

            $animate.enter(angularDomEl, appendToElement)
              .then(function () {
                  $compile(angularDomEl)(modal.scope);
                  $animate.addClass(appendToElement, modalBodyClass);
              });

            openedWindows.top().value.modalDomEl = angularDomEl;
            openedWindows.top().value.modalOpener = modalOpener;

            $modalStack.clearFocusListCache();
        };

        function broadcastClosing(modalWindow, resultOrReason, closing) {
            return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
        }

        $modalStack.close = function (modalInstance, result) {
            var modalWindow = openedWindows.get(modalInstance);
            if (modalWindow && broadcastClosing(modalWindow, result, true)) {
                modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                modalWindow.value.deferred.resolve(result);
                removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                return true;
            }
            return !modalWindow;
        };

        $modalStack.dismiss = function (modalInstance, reason) {
            var modalWindow = openedWindows.get(modalInstance);
            if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
                modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                modalWindow.value.deferred.reject(reason);
                removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                return true;
            }
            return !modalWindow;
        };

        $modalStack.dismissAll = function (reason) {
            var topModal = this.getTop();
            while (topModal && this.dismiss(topModal.key, reason)) {
                topModal = this.getTop();
            }
        };

        $modalStack.getTop = function () {
            return openedWindows.top();
        };

        $modalStack.modalRendered = function (modalInstance) {
            var modalWindow = openedWindows.get(modalInstance);
            if (modalWindow) {
                modalWindow.value.renderDeferred.resolve();
            }
        };

        $modalStack.focusFirstFocusableElement = function () {
            if (focusableElementList.length > 0) {
                focusableElementList[0].focus();
                return true;
            }
            return false;
        };
        $modalStack.focusLastFocusableElement = function () {
            if (focusableElementList.length > 0) {
                focusableElementList[focusableElementList.length - 1].focus();
                return true;
            }
            return false;
        };

        $modalStack.isFocusInFirstItem = function (evt) {
            if (focusableElementList.length > 0) {
                return (evt.target || evt.srcElement) === focusableElementList[0];
            }
            return false;
        };

        $modalStack.isFocusInLastItem = function (evt) {
            if (focusableElementList.length > 0) {
                return (evt.target || evt.srcElement) === focusableElementList[focusableElementList.length - 1];
            }
            return false;
        };

        $modalStack.clearFocusListCache = function () {
            focusableElementList = [];
            focusIndex = 0;
        };

        $modalStack.loadFocusElementList = function (modalWindow) {
            if (focusableElementList === undefined || !focusableElementList.length) {
                if (modalWindow) {
                    var modalDomE1 = modalWindow.value.modalDomEl;
                    if (modalDomE1 && modalDomE1.length) {
                        focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
                    }
                }
            }
        };

        return $modalStack;
    }])

  .provider('$uibModal', function () {
      var $modalProvider = {
          options: {
              animation: true,
              backdrop: true, //can also be false or 'static'
              keyboard: true
          },
          $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',
            function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
                var $modal = {};

                function getTemplatePromise(options) {
                    return options.template ? $q.when(options.template) :
                      $templateRequest(angular.isFunction(options.templateUrl) ?
                        options.templateUrl() : options.templateUrl);
                }

                var promiseChain = null;
                $modal.getPromiseChain = function () {
                    return promiseChain;
                };

                $modal.open = function (modalOptions) {
                    var modalResultDeferred = $q.defer();
                    var modalOpenedDeferred = $q.defer();
                    var modalClosedDeferred = $q.defer();
                    var modalRenderDeferred = $q.defer();

                    //prepare an instance of a modal to be injected into controllers and returned to a caller
                    var modalInstance = {
                        result: modalResultDeferred.promise,
                        opened: modalOpenedDeferred.promise,
                        closed: modalClosedDeferred.promise,
                        rendered: modalRenderDeferred.promise,
                        close: function (result) {
                            return $modalStack.close(modalInstance, result);
                        },
                        dismiss: function (reason) {
                            return $modalStack.dismiss(modalInstance, reason);
                        }
                    };

                    //merge and clean up options
                    modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
                    modalOptions.resolve = modalOptions.resolve || {};
                    modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);

                    //verify options
                    if (!modalOptions.template && !modalOptions.templateUrl) {
                        throw new Error('One of template or templateUrl options is required.');
                    }

                    var templateAndResolvePromise =
                      $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);

                    function resolveWithTemplate() {
                        return templateAndResolvePromise;
                    }

                    // Wait for the resolution of the existing promise chain.
                    // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
                    // Then add to $modalStack and resolve opened.
                    // Finally clean up the chain variable if no subsequent modal has overwritten it.
                    var samePromise;
                    samePromise = promiseChain = $q.all([promiseChain])
                      .then(resolveWithTemplate, resolveWithTemplate)
                      .then(function resolveSuccess(tplAndVars) {
                          var providedScope = modalOptions.scope || $rootScope;

                          var modalScope = providedScope.$new();
                          modalScope.$close = modalInstance.close;
                          modalScope.$dismiss = modalInstance.dismiss;

                          modalScope.$on('$destroy', function () {
                              if (!modalScope.$$uibDestructionScheduled) {
                                  modalScope.$dismiss('$uibUnscheduledDestruction');
                              }
                          });

                          var ctrlInstance, ctrlLocals = {};

                          //controllers
                          if (modalOptions.controller) {
                              ctrlLocals.$scope = modalScope;
                              ctrlLocals.$uibModalInstance = modalInstance;
                              angular.forEach(tplAndVars[1], function (value, key) {
                                  ctrlLocals[key] = value;
                              });

                              ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                              if (modalOptions.controllerAs) {
                                  if (modalOptions.bindToController) {
                                      ctrlInstance.$close = modalScope.$close;
                                      ctrlInstance.$dismiss = modalScope.$dismiss;
                                      angular.extend(ctrlInstance, providedScope);
                                  }

                                  modalScope[modalOptions.controllerAs] = ctrlInstance;
                              }
                          }

                          $modalStack.open(modalInstance, {
                              scope: modalScope,
                              deferred: modalResultDeferred,
                              renderDeferred: modalRenderDeferred,
                              closedDeferred: modalClosedDeferred,
                              content: tplAndVars[0],
                              animation: modalOptions.animation,
                              backdrop: modalOptions.backdrop,
                              keyboard: modalOptions.keyboard,
                              backdropClass: modalOptions.backdropClass,
                              windowTopClass: modalOptions.windowTopClass,
                              windowClass: modalOptions.windowClass,
                              windowTemplateUrl: modalOptions.windowTemplateUrl,
                              size: modalOptions.size,
                              openedClass: modalOptions.openedClass,
                              appendTo: modalOptions.appendTo
                          });
                          modalOpenedDeferred.resolve(true);

                      }, function resolveError(reason) {
                          modalOpenedDeferred.reject(reason);
                          modalResultDeferred.reject(reason);
                      })['finally'](function () {
                          if (promiseChain === samePromise) {
                              promiseChain = null;
                          }
                      });

                    return modalInstance;
                };

                return $modal;
            }
          ]
      };

      return $modalProvider;
  });

angular.module('ui.bootstrap.paging', [])
/**
 * Helper internal service for generating common controller code between the
 * pager and pagination components
 */
.factory('uibPaging', ['$parse', function ($parse) {
    return {
        create: function (ctrl, $scope, $attrs) {
            ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
            ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl

            ctrl.init = function (ngModelCtrl, config) {
                ctrl.ngModelCtrl = ngModelCtrl;
                ctrl.config = config;

                ngModelCtrl.$render = function () {
                    ctrl.render();
                };

                if ($attrs.itemsPerPage) {
                    $scope.$parent.$watch($parse($attrs.itemsPerPage), function (value) {
                        ctrl.itemsPerPage = parseInt(value, 10);
                        $scope.totalPages = ctrl.calculateTotalPages();
                        ctrl.updatePage();
                    });
                } else {
                    ctrl.itemsPerPage = config.itemsPerPage;
                }

                $scope.$watch('totalItems', function (newTotal, oldTotal) {
                    if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
                        $scope.totalPages = ctrl.calculateTotalPages();
                        ctrl.updatePage();
                    }
                });
            };

            ctrl.calculateTotalPages = function () {
                var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
                return Math.max(totalPages || 0, 1);
            };

            ctrl.render = function () {
                $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
            };

            $scope.selectPage = function (page, evt) {
                if (evt) {
                    evt.preventDefault();
                }

                var clickAllowed = !$scope.ngDisabled || !evt;
                if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
                    if (evt && evt.target) {
                        evt.target.blur();
                    }
                    ctrl.ngModelCtrl.$setViewValue(page);
                    ctrl.ngModelCtrl.$render();
                }
            };

            $scope.getText = function (key) {
                return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
            };

            $scope.noPrevious = function () {
                return $scope.page === 1;
            };

            $scope.noNext = function () {
                return $scope.page === $scope.totalPages;
            };

            ctrl.updatePage = function () {
                ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable

                if ($scope.page > $scope.totalPages) {
                    $scope.selectPage($scope.totalPages);
                } else {
                    ctrl.ngModelCtrl.$render();
                }
            };
        }
    };
}]);

angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])

.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function ($scope, $attrs, uibPaging, uibPagerConfig) {
    $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;

    uibPaging.create(this, $scope, $attrs);
}])

.constant('uibPagerConfig', {
    itemsPerPage: 10,
    previousText: '« Previous',
    nextText: 'Next »',
    align: true
})

.directive('uibPager', ['uibPagerConfig', function (uibPagerConfig) {
    return {
        scope: {
            totalItems: '=',
            previousText: '@',
            nextText: '@',
            ngDisabled: '='
        },
        require: ['uibPager', '?ngModel'],
        controller: 'UibPagerController',
        controllerAs: 'pager',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/pager/pager.html';
        },
        replace: true,
        link: function (scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

            if (!ngModelCtrl) {
                return; // do nothing if no ng-model
            }

            paginationCtrl.init(ngModelCtrl, uibPagerConfig);
        }
    };
}]);

angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])
.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function ($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
    var ctrl = this;
    // Setup configuration parameters
    var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,
      rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,
      forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,
      boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers;
    $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
    $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;

    uibPaging.create(this, $scope, $attrs);

    if ($attrs.maxSize) {
        $scope.$parent.$watch($parse($attrs.maxSize), function (value) {
            maxSize = parseInt(value, 10);
            ctrl.render();
        });
    }

    // Create page object used in template
    function makePage(number, text, isActive) {
        return {
            number: number,
            text: text,
            active: isActive
        };
    }

    function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

        // recompute if maxSize
        if (isMaxSized) {
            if (rotate) {
                // Current page is displayed in the middle of the visible ones
                startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                endPage = startPage + maxSize - 1;

                // Adjust if limit is exceeded
                if (endPage > totalPages) {
                    endPage = totalPages;
                    startPage = endPage - maxSize + 1;
                }
            } else {
                // Visible pages are paginated with maxSize
                startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;

                // Adjust last page if limit is exceeded
                endPage = Math.min(startPage + maxSize - 1, totalPages);
            }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
            var page = makePage(number, number, number === currentPage);
            pages.push(page);
        }

        // Add links to move between page sets
        if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
            if (startPage > 1) {
                if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning
                    var previousPageSet = makePage(startPage - 1, '...', false);
                    pages.unshift(previousPageSet);
                }
                if (boundaryLinkNumbers) {
                    if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential
                        var secondPageLink = makePage(2, '2', false);
                        pages.unshift(secondPageLink);
                    }
                    //add the first page
                    var firstPageLink = makePage(1, '1', false);
                    pages.unshift(firstPageLink);
                }
            }

            if (endPage < totalPages) {
                if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end
                    var nextPageSet = makePage(endPage + 1, '...', false);
                    pages.push(nextPageSet);
                }
                if (boundaryLinkNumbers) {
                    if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential
                        var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
                        pages.push(secondToLastPageLink);
                    }
                    //add the last page
                    var lastPageLink = makePage(totalPages, totalPages, false);
                    pages.push(lastPageLink);
                }
            }
        }
        return pages;
    }

    var originalRender = this.render;
    this.render = function () {
        originalRender();
        if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
            $scope.pages = getPages($scope.page, $scope.totalPages);
        }
    };
}])

.constant('uibPaginationConfig', {
    itemsPerPage: 10,
    boundaryLinks: false,
    boundaryLinkNumbers: false,
    directionLinks: true,
    firstText: 'First',
    previousText: 'Previous',
    nextText: 'Next',
    lastText: 'Last',
    rotate: true,
    forceEllipses: false
})

.directive('uibPagination', ['$parse', 'uibPaginationConfig', function ($parse, uibPaginationConfig) {
    return {
        scope: {
            totalItems: '=',
            firstText: '@',
            previousText: '@',
            nextText: '@',
            lastText: '@',
            ngDisabled: '='
        },
        require: ['uibPagination', '?ngModel'],
        controller: 'UibPaginationController',
        controllerAs: 'pagination',
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/pagination/pagination.html';
        },
        replace: true,
        link: function (scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

            if (!ngModelCtrl) {
                return; // do nothing if no ng-model
            }

            paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
        }
    };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$uibTooltip', function () {
    // The default options tooltip and popover.
    var defaultOptions = {
        placement: 'top',
        placementClassPrefix: '',
        animation: true,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: false
    };

    // Default hide triggers for each show trigger
    var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'outsideClick': 'outsideClick',
        'focus': 'blur',
        'none': ''
    };

    // The options specified to the provider globally.
    var globalOptions = {};

    /**
     * `options({})` allows global configuration of all tooltips in the
     * application.
     *
     *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
     *     // place tooltips left instead of top by default
     *     $tooltipProvider.options( { placement: 'left' } );
     *   });
     */
    this.options = function (value) {
        angular.extend(globalOptions, value);
    };

    /**
     * This allows you to extend the set of trigger mappings available. E.g.:
     *
     *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
     */
    this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
    };

    /**
     * This is a helper function for translating camel-case to snake_case.
     */
    function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function (letter, pos) {
            return (pos ? separator : '') + letter.toLowerCase();
        });
    }

    /**
     * Returns the actual instance of the $tooltip service.
     * TODO support multiple triggers
     */
    this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function ($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        var openedTooltips = $$stackedMap.createNew();
        $document.on('keypress', keypressListener);

        $rootScope.$on('$destroy', function () {
            $document.off('keypress', keypressListener);
        });

        function keypressListener(e) {
            if (e.which === 27) {
                var last = openedTooltips.top();
                if (last) {
                    last.value.close();
                    openedTooltips.removeTop();
                    last = null;
                }
            }
        }

        return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
            options = angular.extend({}, defaultOptions, globalOptions, options);

            /**
             * Returns an object of show and hide triggers.
             *
             * If a trigger is supplied,
             * it is used to show the tooltip; otherwise, it will use the `trigger`
             * option passed to the `$tooltipProvider.options` method; else it will
             * default to the trigger supplied to this directive factory.
             *
             * The hide trigger is based on the show trigger. If the `trigger` option
             * was passed to the `$tooltipProvider.options` method, it will use the
             * mapped trigger from `triggerMap` or the passed trigger if the map is
             * undefined; otherwise, it uses the `triggerMap` value of the show
             * trigger; else it will just use the show trigger.
             */
            function getTriggers(trigger) {
                var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
                var hide = show.map(function (trigger) {
                    return triggerMap[trigger] || trigger;
                });
                return {
                    show: show,
                    hide: hide
                };
            }

            var directiveName = snake_case(ttType);

            var startSym = $interpolate.startSymbol();
            var endSym = $interpolate.endSymbol();
            var template =
              '<div ' + directiveName + '-popup ' +
                'title="' + startSym + 'title' + endSym + '" ' +
                (options.useContentExp ?
                  'content-exp="contentExp()" ' :
                  'content="' + startSym + 'content' + endSym + '" ') +
                'placement="' + startSym + 'placement' + endSym + '" ' +
                'popup-class="' + startSym + 'popupClass' + endSym + '" ' +
                'animation="animation" ' +
                'is-open="isOpen"' +
                'origin-scope="origScope" ' +
                'style="visibility: hidden; display: block; top: -9999px; left: -9999px;"' +
                '>' +
              '</div>';

            return {
                compile: function (tElem, tAttrs) {
                    var tooltipLinker = $compile(template);

                    return function link(scope, element, attrs, tooltipCtrl) {
                        var tooltip;
                        var tooltipLinkedScope;
                        var transitionTimeout;
                        var showTimeout;
                        var hideTimeout;
                        var positionTimeout;
                        var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                        var triggers = getTriggers(undefined);
                        var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                        var ttScope = scope.$new(true);
                        var repositionScheduled = false;
                        var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                        var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                        var observers = [];

                        var positionTooltip = function () {
                            // check if tooltip exists and is not empty
                            if (!tooltip || !tooltip.html()) { return; }

                            if (!positionTimeout) {
                                positionTimeout = $timeout(function () {
                                    // Reset the positioning.
                                    tooltip.css({ top: 0, left: 0 });

                                    // Now set the calculated positioning.
                                    var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                                    tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px', visibility: 'visible' });

                                    // If the placement class is prefixed, still need
                                    // to remove the TWBS standard class.
                                    if (options.placementClassPrefix) {
                                        tooltip.removeClass('top bottom left right');
                                    }

                                    tooltip.removeClass(
                                      options.placementClassPrefix + 'top ' +
                                      options.placementClassPrefix + 'top-left ' +
                                      options.placementClassPrefix + 'top-right ' +
                                      options.placementClassPrefix + 'bottom ' +
                                      options.placementClassPrefix + 'bottom-left ' +
                                      options.placementClassPrefix + 'bottom-right ' +
                                      options.placementClassPrefix + 'left ' +
                                      options.placementClassPrefix + 'left-top ' +
                                      options.placementClassPrefix + 'left-bottom ' +
                                      options.placementClassPrefix + 'right ' +
                                      options.placementClassPrefix + 'right-top ' +
                                      options.placementClassPrefix + 'right-bottom');

                                    var placement = ttPosition.placement.split('-');
                                    tooltip.addClass(placement[0], options.placementClassPrefix + ttPosition.placement);
                                    $position.positionArrow(tooltip, ttPosition.placement);

                                    positionTimeout = null;
                                }, 0, false);
                            }
                        };

                        // Set up the correct scope to allow transclusion later
                        ttScope.origScope = scope;

                        // By default, the tooltip is not open.
                        // TODO add ability to start tooltip opened
                        ttScope.isOpen = false;
                        openedTooltips.add(ttScope, {
                            close: hide
                        });

                        function toggleTooltipBind() {
                            if (!ttScope.isOpen) {
                                showTooltipBind();
                            } else {
                                hideTooltipBind();
                            }
                        }

                        // Show the tooltip with delay if specified, otherwise show it immediately
                        function showTooltipBind() {
                            if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                                return;
                            }

                            cancelHide();
                            prepareTooltip();

                            if (ttScope.popupDelay) {
                                // Do nothing if the tooltip was already scheduled to pop-up.
                                // This happens if show is triggered multiple times before any hide is triggered.
                                if (!showTimeout) {
                                    showTimeout = $timeout(show, ttScope.popupDelay, false);
                                }
                            } else {
                                show();
                            }
                        }

                        function hideTooltipBind() {
                            cancelShow();

                            if (ttScope.popupCloseDelay) {
                                if (!hideTimeout) {
                                    hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                                }
                            } else {
                                hide();
                            }
                        }

                        // Show the tooltip popup element.
                        function show() {
                            cancelShow();
                            cancelHide();

                            // Don't show empty tooltips.
                            if (!ttScope.content) {
                                return angular.noop;
                            }

                            createTooltip();

                            // And show the tooltip.
                            ttScope.$evalAsync(function () {
                                ttScope.isOpen = true;
                                assignIsOpen(true);
                                positionTooltip();
                            });
                        }

                        function cancelShow() {
                            if (showTimeout) {
                                $timeout.cancel(showTimeout);
                                showTimeout = null;
                            }

                            if (positionTimeout) {
                                $timeout.cancel(positionTimeout);
                                positionTimeout = null;
                            }
                        }

                        // Hide the tooltip popup element.
                        function hide() {
                            if (!ttScope) {
                                return;
                            }

                            // First things first: we don't show it anymore.
                            ttScope.$evalAsync(function () {
                                ttScope.isOpen = false;
                                assignIsOpen(false);
                                // And now we remove it from the DOM. However, if we have animation, we
                                // need to wait for it to expire beforehand.
                                // FIXME: this is a placeholder for a port of the transitions library.
                                // The fade transition in TWBS is 150ms.
                                if (ttScope.animation) {
                                    if (!transitionTimeout) {
                                        transitionTimeout = $timeout(removeTooltip, 150, false);
                                    }
                                } else {
                                    removeTooltip();
                                }
                            });
                        }

                        function cancelHide() {
                            if (hideTimeout) {
                                $timeout.cancel(hideTimeout);
                                hideTimeout = null;
                            }
                            if (transitionTimeout) {
                                $timeout.cancel(transitionTimeout);
                                transitionTimeout = null;
                            }
                        }

                        function createTooltip() {
                            // There can only be one tooltip element per directive shown at once.
                            if (tooltip) {
                                return;
                            }

                            tooltipLinkedScope = ttScope.$new();
                            tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                                if (appendToBody) {
                                    $document.find('body').append(tooltip);
                                } else {
                                    element.after(tooltip);
                                }
                            });

                            prepObservers();
                        }

                        function removeTooltip() {
                            cancelShow();
                            cancelHide();
                            unregisterObservers();

                            if (tooltip) {
                                tooltip.remove();
                                tooltip = null;
                            }
                            if (tooltipLinkedScope) {
                                tooltipLinkedScope.$destroy();
                                tooltipLinkedScope = null;
                            }
                        }

                        /**
                         * Set the initial scope values. Once
                         * the tooltip is created, the observers
                         * will be added to keep things in sync.
                         */
                        function prepareTooltip() {
                            ttScope.title = attrs[prefix + 'Title'];
                            if (contentParse) {
                                ttScope.content = contentParse(scope);
                            } else {
                                ttScope.content = attrs[ttType];
                            }

                            ttScope.popupClass = attrs[prefix + 'Class'];
                            ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;

                            var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                            var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                            ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                            ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                        }

                        function assignIsOpen(isOpen) {
                            if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                                isOpenParse.assign(scope, isOpen);
                            }
                        }

                        ttScope.contentExp = function () {
                            return ttScope.content;
                        };

                        /**
                         * Observe the relevant attributes.
                         */
                        attrs.$observe('disabled', function (val) {
                            if (val) {
                                cancelShow();
                            }

                            if (val && ttScope.isOpen) {
                                hide();
                            }
                        });

                        if (isOpenParse) {
                            scope.$watch(isOpenParse, function (val) {
                                if (ttScope && !val === ttScope.isOpen) {
                                    toggleTooltipBind();
                                }
                            });
                        }

                        function prepObservers() {
                            observers.length = 0;

                            if (contentParse) {
                                observers.push(
                                  scope.$watch(contentParse, function (val) {
                                      ttScope.content = val;
                                      if (!val && ttScope.isOpen) {
                                          hide();
                                      }
                                  })
                                );

                                observers.push(
                                  tooltipLinkedScope.$watch(function () {
                                      if (!repositionScheduled) {
                                          repositionScheduled = true;
                                          tooltipLinkedScope.$$postDigest(function () {
                                              repositionScheduled = false;
                                              if (ttScope && ttScope.isOpen) {
                                                  positionTooltip();
                                              }
                                          });
                                      }
                                  })
                                );
                            } else {
                                observers.push(
                                  attrs.$observe(ttType, function (val) {
                                      ttScope.content = val;
                                      if (!val && ttScope.isOpen) {
                                          hide();
                                      } else {
                                          positionTooltip();
                                      }
                                  })
                                );
                            }

                            observers.push(
                              attrs.$observe(prefix + 'Title', function (val) {
                                  ttScope.title = val;
                                  if (ttScope.isOpen) {
                                      positionTooltip();
                                  }
                              })
                            );

                            observers.push(
                              attrs.$observe(prefix + 'Placement', function (val) {
                                  ttScope.placement = val ? val : options.placement;
                                  if (ttScope.isOpen) {
                                      positionTooltip();
                                  }
                              })
                            );
                        }

                        function unregisterObservers() {
                            if (observers.length) {
                                angular.forEach(observers, function (observer) {
                                    observer();
                                });
                                observers.length = 0;
                            }
                        }

                        // hide tooltips/popovers for outsideClick trigger
                        function bodyHideTooltipBind(e) {
                            if (!ttScope || !ttScope.isOpen || !tooltip) {
                                return;
                            }
                            // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked
                            if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                                hideTooltipBind();
                            }
                        }

                        var unregisterTriggers = function () {
                            triggers.show.forEach(function (trigger) {
                                if (trigger === 'outsideClick') {
                                    element.off('click', toggleTooltipBind);
                                } else {
                                    element.off(trigger, showTooltipBind);
                                    element.off(trigger, toggleTooltipBind);
                                }
                            });
                            triggers.hide.forEach(function (trigger) {
                                if (trigger === 'outsideClick') {
                                    $document.off('click', bodyHideTooltipBind);
                                } else {
                                    element.off(trigger, hideTooltipBind);
                                }
                            });
                        };

                        function prepTriggers() {
                            var val = attrs[prefix + 'Trigger'];
                            unregisterTriggers();

                            triggers = getTriggers(val);

                            if (triggers.show !== 'none') {
                                triggers.show.forEach(function (trigger, idx) {
                                    if (trigger === 'outsideClick') {
                                        element.on('click', toggleTooltipBind);
                                        $document.on('click', bodyHideTooltipBind);
                                    } else if (trigger === triggers.hide[idx]) {
                                        element.on(trigger, toggleTooltipBind);
                                    } else if (trigger) {
                                        element.on(trigger, showTooltipBind);
                                        element.on(triggers.hide[idx], hideTooltipBind);
                                    }

                                    element.on('keypress', function (e) {
                                        if (e.which === 27) {
                                            hideTooltipBind();
                                        }
                                    });
                                });
                            }
                        }

                        prepTriggers();

                        var animation = scope.$eval(attrs[prefix + 'Animation']);
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

                        var appendToBodyVal;
                        var appendKey = prefix + 'AppendToBody';
                        if (appendKey in attrs && attrs[appendKey] === undefined) {
                            appendToBodyVal = true;
                        } else {
                            appendToBodyVal = scope.$eval(attrs[appendKey]);
                        }

                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

                        // if a tooltip is attached to <body> we need to remove it on
                        // location change as its parent scope will probably not be destroyed
                        // by the change.
                        if (appendToBody) {
                            scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                                if (ttScope.isOpen) {
                                    hide();
                                }
                            });
                        }

                        // Make sure tooltip is destroyed and removed.
                        scope.$on('$destroy', function onDestroyTooltip() {
                            unregisterTriggers();
                            removeTooltip();
                            openedTooltips.remove(ttScope);
                            ttScope = null;
                        });
                    };
                }
            };
        };
    }];
})

// This is mostly ngInclude code but with a custom scope
.directive('uibTooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest',
function ($animate, $sce, $compile, $templateRequest) {
    return {
        link: function (scope, elem, attrs) {
            var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

            var changeCounter = 0,
              currentScope,
              previousElement,
              currentElement;

            var cleanupLastIncludeContent = function () {
                if (previousElement) {
                    previousElement.remove();
                    previousElement = null;
                }

                if (currentScope) {
                    currentScope.$destroy();
                    currentScope = null;
                }

                if (currentElement) {
                    $animate.leave(currentElement).then(function () {
                        previousElement = null;
                    });
                    previousElement = currentElement;
                    currentElement = null;
                }
            };

            scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function (src) {
                var thisChangeId = ++changeCounter;

                if (src) {
                    //set the 2nd param to true to ignore the template request error so that the inner
                    //contents and scope can be cleaned up.
                    $templateRequest(src, true).then(function (response) {
                        if (thisChangeId !== changeCounter) { return; }
                        var newScope = origScope.$new();
                        var template = response;

                        var clone = $compile(template)(newScope, function (clone) {
                            cleanupLastIncludeContent();
                            $animate.enter(clone, elem);
                        });

                        currentScope = newScope;
                        currentElement = clone;

                        currentScope.$emit('$includeContentLoaded', src);
                    }, function () {
                        if (thisChangeId === changeCounter) {
                            cleanupLastIncludeContent();
                            scope.$emit('$includeContentError', src);
                        }
                    });
                    scope.$emit('$includeContentRequested', src);
                } else {
                    cleanupLastIncludeContent();
                }
            });

            scope.$on('$destroy', cleanupLastIncludeContent);
        }
    };
}])

/**
 * Note that it's intentional that these classes are *not* applied through $animate.
 * They must not be animated as they're expected to be present on the tooltip on
 * initialization.
 */
.directive('uibTooltipClasses', ['$uibPosition', function ($uibPosition) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            // need to set the primary position so the
            // arrow has space during position measure.
            // tooltip.positionTooltip()
            if (scope.placement) {
                // // There are no top-left etc... classes
                // // in TWBS, so we need the primary position.
                var position = $uibPosition.parsePlacement(scope.placement);
                element.addClass(position[0]);
            } else {
                element.addClass('top');
            }

            if (scope.popupClass) {
                element.addClass(scope.popupClass);
            }

            if (scope.animation()) {
                element.addClass(attrs.tooltipAnimationClass);
            }
        }
    };
}])

.directive('uibTooltipPopup', function () {
    return {
        replace: true,
        scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
        templateUrl: 'uib/template/tooltip/tooltip-popup.html'
    };
})

.directive('uibTooltip', ['$uibTooltip', function ($uibTooltip) {
    return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
}])

.directive('uibTooltipTemplatePopup', function () {
    return {
        replace: true,
        scope: {
            contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
            originScope: '&'
        },
        templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
    };
})

.directive('uibTooltipTemplate', ['$uibTooltip', function ($uibTooltip) {
    return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
        useContentExp: true
    });
}])

.directive('uibTooltipHtmlPopup', function () {
    return {
        replace: true,
        scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
        templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
    };
})

.directive('uibTooltipHtml', ['$uibTooltip', function ($uibTooltip) {
    return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
        useContentExp: true
    });
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

.directive('uibPopoverTemplatePopup', function () {
    return {
        replace: true,
        scope: {
            title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
            originScope: '&'
        },
        templateUrl: 'uib/template/popover/popover-template.html'
    };
})

.directive('uibPopoverTemplate', ['$uibTooltip', function ($uibTooltip) {
    return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
        useContentExp: true
    });
}])

.directive('uibPopoverHtmlPopup', function () {
    return {
        replace: true,
        scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
        templateUrl: 'uib/template/popover/popover-html.html'
    };
})

.directive('uibPopoverHtml', ['$uibTooltip', function ($uibTooltip) {
    return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
        useContentExp: true
    });
}])

.directive('uibPopoverPopup', function () {
    return {
        replace: true,
        scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
        templateUrl: 'uib/template/popover/popover.html'
    };
})

.directive('uibPopover', ['$uibTooltip', function ($uibTooltip) {
    return $uibTooltip('uibPopover', 'popover', 'click');
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('uibProgressConfig', {
    animate: true,
    max: 100
})

.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function ($scope, $attrs, progressConfig) {
    var self = this,
        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

    this.bars = [];
    $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;

    this.addBar = function (bar, element, attrs) {
        if (!animate) {
            element.css({ 'transition': 'none' });
        }

        this.bars.push(bar);

        bar.max = $scope.max;
        bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

        bar.$watch('value', function (value) {
            bar.recalculatePercentage();
        });

        bar.recalculatePercentage = function () {
            var totalPercentage = self.bars.reduce(function (total, bar) {
                bar.percent = +(100 * bar.value / bar.max).toFixed(2);
                return total + bar.percent;
            }, 0);

            if (totalPercentage > 100) {
                bar.percent -= totalPercentage - 100;
            }
        };

        bar.$on('$destroy', function () {
            element = null;
            self.removeBar(bar);
        });
    };

    this.removeBar = function (bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
        this.bars.forEach(function (bar) {
            bar.recalculatePercentage();
        });
    };

    $scope.$watch('max', function (max) {
        self.bars.forEach(function (bar) {
            bar.max = $scope.max;
            bar.recalculatePercentage();
        });
    });
}])

.directive('uibProgress', function () {
    return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        require: 'uibProgress',
        scope: {
            max: '=?'
        },
        templateUrl: 'uib/template/progressbar/progress.html'
    };
})

.directive('uibBar', function () {
    return {
        replace: true,
        transclude: true,
        require: '^uibProgress',
        scope: {
            value: '=',
            type: '@'
        },
        templateUrl: 'uib/template/progressbar/bar.html',
        link: function (scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element, attrs);
        }
    };
})

.directive('uibProgressbar', function () {
    return {
        replace: true,
        transclude: true,
        controller: 'UibProgressController',
        scope: {
            value: '=',
            max: '=?',
            type: '@'
        },
        templateUrl: 'uib/template/progressbar/progressbar.html',
        link: function (scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]), { title: attrs.title });
        }
    };
});

angular.module('ui.bootstrap.rating', [])

.constant('uibRatingConfig', {
    max: 5,
    stateOn: null,
    stateOff: null,
    titles: ['one', 'two', 'three', 'four', 'five']
})

.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function ($scope, $attrs, ratingConfig) {
    var ngModelCtrl = { $setViewValue: angular.noop };

    this.init = function (ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;

        ngModelCtrl.$formatters.push(function (value) {
            if (angular.isNumber(value) && value << 0 !== value) {
                value = Math.round(value);
            }

            return value;
        });

        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
            tmpTitles : ratingConfig.titles;

        var ratingStates = angular.isDefined($attrs.ratingStates) ?
          $scope.$parent.$eval($attrs.ratingStates) :
          new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
    };

    this.buildTemplateObjects = function (states) {
        for (var i = 0, n = states.length; i < n; i++) {
            states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
        }
        return states;
    };

    this.getTitle = function (index) {
        if (index >= this.titles.length) {
            return index + 1;
        }

        return this.titles[index];
    };

    $scope.rate = function (value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
            ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
            ngModelCtrl.$render();
        }
    };

    $scope.enter = function (value) {
        if (!$scope.readonly) {
            $scope.value = value;
        }
        $scope.onHover({ value: value });
    };

    $scope.reset = function () {
        $scope.value = ngModelCtrl.$viewValue;
        $scope.onLeave();
    };

    $scope.onKeydown = function (evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
            evt.preventDefault();
            evt.stopPropagation();
            $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
        }
    };

    this.render = function () {
        $scope.value = ngModelCtrl.$viewValue;
    };
}])

.directive('uibRating', function () {
    return {
        require: ['uibRating', 'ngModel'],
        scope: {
            readonly: '=?',
            onHover: '&',
            onLeave: '&'
        },
        controller: 'UibRatingController',
        templateUrl: 'uib/template/rating/rating.html',
        replace: true,
        link: function (scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
});

angular.module('ui.bootstrap.tabs', [])

.controller('UibTabsetController', ['$scope', function ($scope) {
    var ctrl = this,
        tabs = ctrl.tabs = $scope.tabs = [];

    ctrl.select = function (selectedTab) {
        angular.forEach(tabs, function (tab) {
            if (tab.active && tab !== selectedTab) {
                tab.active = false;
                tab.onDeselect();
                selectedTab.selectCalled = false;
            }
        });
        selectedTab.active = true;
        // only call select if it has not already been called
        if (!selectedTab.selectCalled) {
            selectedTab.onSelect();
            selectedTab.selectCalled = true;
        }
    };

    ctrl.addTab = function addTab(tab) {
        tabs.push(tab);
        // we can't run the select function on the first tab
        // since that would select it twice
        if (tabs.length === 1 && tab.active !== false) {
            tab.active = true;
        } else if (tab.active) {
            ctrl.select(tab);
        } else {
            tab.active = false;
        }
    };

    ctrl.removeTab = function removeTab(tab) {
        var index = tabs.indexOf(tab);
        //Select a new tab if the tab to be removed is selected and not destroyed
        if (tab.active && tabs.length > 1 && !destroyed) {
            //If this is the last tab, select the previous tab. else, the next tab.
            var newActiveIndex = index === tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
    };

    var destroyed;
    $scope.$on('$destroy', function () {
        destroyed = true;
    });
}])

.directive('uibTabset', function () {
    return {
        transclude: true,
        replace: true,
        scope: {
            type: '@'
        },
        controller: 'UibTabsetController',
        templateUrl: 'template/tabs/tabset.html',
        link: function (scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
        }
    };
})

.directive('uibTab', ['$parse', function ($parse) {
    return {
        require: '^uibTabset',
        replace: true,
        templateUrl: 'template/tabs/tab.html',
        transclude: true,
        scope: {
            active: '=?',
            heading: '@',
            onSelect: '&select', //This callback is called in contentHeadingTransclude
            //once it inserts the tab's content into the dom
            onDeselect: '&deselect'
        },
        controller: function () {
            //Empty controller so other directives can require being 'under' a tab
        },
        controllerAs: 'tab',
        link: function (scope, elm, attrs, tabsetCtrl, transclude) {
            scope.$watch('active', function (active) {
                if (active) {
                    tabsetCtrl.select(scope);
                }
            });

            scope.disabled = false;
            if (attrs.disable) {
                scope.$parent.$watch($parse(attrs.disable), function (value) {
                    scope.disabled = !!value;
                });
            }

            scope.select = function () {
                if (!scope.disabled) {
                    scope.active = true;
                }
            };

            tabsetCtrl.addTab(scope);
            scope.$on('$destroy', function () {
                tabsetCtrl.removeTab(scope);
            });

            //We need to transclude later, once the content container is ready.
            //when this link happens, we're inside a tab heading.
            scope.$transcludeFn = transclude;
        }
    };
}])

.directive('uibTabHeadingTransclude', function () {
    return {
        restrict: 'A',
        require: '^uibTab',
        link: function (scope, elm) {
            scope.$watch('headingElement', function updateHeadingElement(heading) {
                if (heading) {
                    elm.html('');
                    elm.append(heading);
                }
            });
        }
    };
})

.directive('uibTabContentTransclude', function () {
    return {
        restrict: 'A',
        require: '^uibTabset',
        link: function (scope, elm, attrs) {
            var tab = scope.$eval(attrs.uibTabContentTransclude);

            //Now our tab is ready to be transcluded: both the tab heading area
            //and the tab content area are loaded.  Transclude 'em both.
            tab.$transcludeFn(tab.$parent, function (contents) {
                angular.forEach(contents, function (node) {
                    if (isTabHeading(node)) {
                        //Let tabHeadingTransclude know.
                        tab.headingElement = node;
                    } else {
                        elm.append(node);
                    }
                });
            });
        }
    };

    function isTabHeading(node) {
        return node.tagName && (
          node.hasAttribute('uib-tab-heading') ||
          node.hasAttribute('data-uib-tab-heading') ||
          node.hasAttribute('x-uib-tab-heading') ||
          node.tagName.toLowerCase() === 'uib-tab-heading' ||
          node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
          node.tagName.toLowerCase() === 'x-uib-tab-heading'
        );
    }
});

angular.module('ui.bootstrap.timepicker', [])

.constant('uibTimepickerConfig', {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: true,
    showSeconds: false,
    meridians: null,
    readonlyInput: false,
    mousewheel: true,
    arrowkeys: true,
    showSpinners: true
})

.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function ($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
    var selected = new Date(),
        ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
        meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

    $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
    $element.removeAttr('tabindex');

    this.init = function (ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_;
        ngModelCtrl.$render = this.render;

        ngModelCtrl.$formatters.unshift(function (modelValue) {
            return modelValue ? new Date(modelValue) : null;
        });

        var hoursInputEl = inputs.eq(0),
            minutesInputEl = inputs.eq(1),
            secondsInputEl = inputs.eq(2);

        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;

        if (mousewheel) {
            this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        }

        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        if (arrowkeys) {
            this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        }

        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
        this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    };

    var hourStep = timepickerConfig.hourStep;
    if ($attrs.hourStep) {
        $scope.$parent.$watch($parse($attrs.hourStep), function (value) {
            hourStep = parseInt(value, 10);
        });
    }

    var minuteStep = timepickerConfig.minuteStep;
    if ($attrs.minuteStep) {
        $scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
            minuteStep = parseInt(value, 10);
        });
    }

    var min;
    $scope.$parent.$watch($parse($attrs.min), function (value) {
        var dt = new Date(value);
        min = isNaN(dt) ? undefined : dt;
    });

    var max;
    $scope.$parent.$watch($parse($attrs.max), function (value) {
        var dt = new Date(value);
        max = isNaN(dt) ? undefined : dt;
    });

    var disabled = false;
    if ($attrs.ngDisabled) {
        $scope.$parent.$watch($parse($attrs.ngDisabled), function (value) {
            disabled = value;
        });
    }

    $scope.noIncrementHours = function () {
        var incrementedSelected = addMinutes(selected, hourStep * 60);
        return disabled || incrementedSelected > max ||
          incrementedSelected < selected && incrementedSelected < min;
    };

    $scope.noDecrementHours = function () {
        var decrementedSelected = addMinutes(selected, -hourStep * 60);
        return disabled || decrementedSelected < min ||
          decrementedSelected > selected && decrementedSelected > max;
    };

    $scope.noIncrementMinutes = function () {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return disabled || incrementedSelected > max ||
          incrementedSelected < selected && incrementedSelected < min;
    };

    $scope.noDecrementMinutes = function () {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return disabled || decrementedSelected < min ||
          decrementedSelected > selected && decrementedSelected > max;
    };

    $scope.noIncrementSeconds = function () {
        var incrementedSelected = addSeconds(selected, secondStep);
        return disabled || incrementedSelected > max ||
          incrementedSelected < selected && incrementedSelected < min;
    };

    $scope.noDecrementSeconds = function () {
        var decrementedSelected = addSeconds(selected, -secondStep);
        return disabled || decrementedSelected < min ||
          decrementedSelected > selected && decrementedSelected > max;
    };

    $scope.noToggleMeridian = function () {
        if (selected.getHours() < 12) {
            return disabled || addMinutes(selected, 12 * 60) > max;
        }

        return disabled || addMinutes(selected, -12 * 60) < min;
    };

    var secondStep = timepickerConfig.secondStep;
    if ($attrs.secondStep) {
        $scope.$parent.$watch($parse($attrs.secondStep), function (value) {
            secondStep = parseInt(value, 10);
        });
    }

    $scope.showSeconds = timepickerConfig.showSeconds;
    if ($attrs.showSeconds) {
        $scope.$parent.$watch($parse($attrs.showSeconds), function (value) {
            $scope.showSeconds = !!value;
        });
    }

    // 12H / 24H mode
    $scope.showMeridian = timepickerConfig.showMeridian;
    if ($attrs.showMeridian) {
        $scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
            $scope.showMeridian = !!value;

            if (ngModelCtrl.$error.time) {
                // Evaluate from template
                var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                    selected.setHours(hours);
                    refresh();
                }
            } else {
                updateTemplate();
            }
        });
    }

    // Get $scope.hours in 24H mode if valid
    function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10);
        var valid = $scope.showMeridian ? hours > 0 && hours < 13 :
          hours >= 0 && hours < 24;
        if (!valid) {
            return undefined;
        }

        if ($scope.showMeridian) {
            if (hours === 12) {
                hours = 0;
            }
            if ($scope.meridian === meridians[1]) {
                hours = hours + 12;
            }
        }
        return hours;
    }

    function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10);
        return minutes >= 0 && minutes < 60 ? minutes : undefined;
    }

    function getSecondsFromTemplate() {
        var seconds = parseInt($scope.seconds, 10);
        return seconds >= 0 && seconds < 60 ? seconds : undefined;
    }

    function pad(value) {
        if (value === null) {
            return '';
        }

        return angular.isDefined(value) && value.toString().length < 2 ?
          '0' + value : value.toString();
    }

    // Respond on mousewheel spin
    this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
        var isScrollingUp = function (e) {
            if (e.originalEvent) {
                e = e.originalEvent;
            }
            //pick correct delta variable depending on event
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
        };

        hoursInputEl.bind('mousewheel wheel', function (e) {
            if (!disabled) {
                $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
            }
            e.preventDefault();
        });

        minutesInputEl.bind('mousewheel wheel', function (e) {
            if (!disabled) {
                $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
            }
            e.preventDefault();
        });

        secondsInputEl.bind('mousewheel wheel', function (e) {
            if (!disabled) {
                $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
            }
            e.preventDefault();
        });
    };

    // Respond on up/down arrowkeys
    this.setupArrowkeyEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
        hoursInputEl.bind('keydown', function (e) {
            if (!disabled) {
                if (e.which === 38) { // up
                    e.preventDefault();
                    $scope.incrementHours();
                    $scope.$apply();
                } else if (e.which === 40) { // down
                    e.preventDefault();
                    $scope.decrementHours();
                    $scope.$apply();
                }
            }
        });

        minutesInputEl.bind('keydown', function (e) {
            if (!disabled) {
                if (e.which === 38) { // up
                    e.preventDefault();
                    $scope.incrementMinutes();
                    $scope.$apply();
                } else if (e.which === 40) { // down
                    e.preventDefault();
                    $scope.decrementMinutes();
                    $scope.$apply();
                }
            }
        });

        secondsInputEl.bind('keydown', function (e) {
            if (!disabled) {
                if (e.which === 38) { // up
                    e.preventDefault();
                    $scope.incrementSeconds();
                    $scope.$apply();
                } else if (e.which === 40) { // down
                    e.preventDefault();
                    $scope.decrementSeconds();
                    $scope.$apply();
                }
            }
        });
    };

    this.setupInputEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
        if ($scope.readonlyInput) {
            $scope.updateHours = angular.noop;
            $scope.updateMinutes = angular.noop;
            $scope.updateSeconds = angular.noop;
            return;
        }

        var invalidate = function (invalidHours, invalidMinutes, invalidSeconds) {
            ngModelCtrl.$setViewValue(null);
            ngModelCtrl.$setValidity('time', false);
            if (angular.isDefined(invalidHours)) {
                $scope.invalidHours = invalidHours;
            }

            if (angular.isDefined(invalidMinutes)) {
                $scope.invalidMinutes = invalidMinutes;
            }

            if (angular.isDefined(invalidSeconds)) {
                $scope.invalidSeconds = invalidSeconds;
            }
        };

        $scope.updateHours = function () {
            var hours = getHoursFromTemplate(),
              minutes = getMinutesFromTemplate();

            ngModelCtrl.$setDirty();

            if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                selected.setHours(hours);
                selected.setMinutes(minutes);
                if (selected < min || selected > max) {
                    invalidate(true);
                } else {
                    refresh('h');
                }
            } else {
                invalidate(true);
            }
        };

        hoursInputEl.bind('blur', function (e) {
            ngModelCtrl.$setTouched();
            if ($scope.hours === null || $scope.hours === '') {
                invalidate(true);
            } else if (!$scope.invalidHours && $scope.hours < 10) {
                $scope.$apply(function () {
                    $scope.hours = pad($scope.hours);
                });
            }
        });

        $scope.updateMinutes = function () {
            var minutes = getMinutesFromTemplate(),
              hours = getHoursFromTemplate();

            ngModelCtrl.$setDirty();

            if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                selected.setHours(hours);
                selected.setMinutes(minutes);
                if (selected < min || selected > max) {
                    invalidate(undefined, true);
                } else {
                    refresh('m');
                }
            } else {
                invalidate(undefined, true);
            }
        };

        minutesInputEl.bind('blur', function (e) {
            ngModelCtrl.$setTouched();
            if ($scope.minutes === null) {
                invalidate(undefined, true);
            } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
                $scope.$apply(function () {
                    $scope.minutes = pad($scope.minutes);
                });
            }
        });

        $scope.updateSeconds = function () {
            var seconds = getSecondsFromTemplate();

            ngModelCtrl.$setDirty();

            if (angular.isDefined(seconds)) {
                selected.setSeconds(seconds);
                refresh('s');
            } else {
                invalidate(undefined, undefined, true);
            }
        };

        secondsInputEl.bind('blur', function (e) {
            if (!$scope.invalidSeconds && $scope.seconds < 10) {
                $scope.$apply(function () {
                    $scope.seconds = pad($scope.seconds);
                });
            }
        });

    };

    this.render = function () {
        var date = ngModelCtrl.$viewValue;

        if (isNaN(date)) {
            ngModelCtrl.$setValidity('time', false);
            $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
            if (date) {
                selected = date;
            }

            if (selected < min || selected > max) {
                ngModelCtrl.$setValidity('time', false);
                $scope.invalidHours = true;
                $scope.invalidMinutes = true;
            } else {
                makeValid();
            }
            updateTemplate();
        }
    };

    // Call internally when we know that model is valid.
    function refresh(keyboardChange) {
        makeValid();
        ngModelCtrl.$setViewValue(new Date(selected));
        updateTemplate(keyboardChange);
    }

    function makeValid() {
        ngModelCtrl.$setValidity('time', true);
        $scope.invalidHours = false;
        $scope.invalidMinutes = false;
        $scope.invalidSeconds = false;
    }

    function updateTemplate(keyboardChange) {
        if (!ngModelCtrl.$modelValue) {
            $scope.hours = null;
            $scope.minutes = null;
            $scope.seconds = null;
            $scope.meridian = meridians[0];
        } else {
            var hours = selected.getHours(),
              minutes = selected.getMinutes(),
              seconds = selected.getSeconds();

            if ($scope.showMeridian) {
                hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system
            }

            $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
            if (keyboardChange !== 'm') {
                $scope.minutes = pad(minutes);
            }
            $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];

            if (keyboardChange !== 's') {
                $scope.seconds = pad(seconds);
            }
            $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        }
    }

    function addSecondsToSelected(seconds) {
        selected = addSeconds(selected, seconds);
        refresh();
    }

    function addMinutes(selected, minutes) {
        return addSeconds(selected, minutes * 60);
    }

    function addSeconds(date, seconds) {
        var dt = new Date(date.getTime() + seconds * 1000);
        var newDate = new Date(date);
        newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
        return newDate;
    }

    $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
      $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

    $scope.incrementHours = function () {
        if (!$scope.noIncrementHours()) {
            addSecondsToSelected(hourStep * 60 * 60);
        }
    };

    $scope.decrementHours = function () {
        if (!$scope.noDecrementHours()) {
            addSecondsToSelected(-hourStep * 60 * 60);
        }
    };

    $scope.incrementMinutes = function () {
        if (!$scope.noIncrementMinutes()) {
            addSecondsToSelected(minuteStep * 60);
        }
    };

    $scope.decrementMinutes = function () {
        if (!$scope.noDecrementMinutes()) {
            addSecondsToSelected(-minuteStep * 60);
        }
    };

    $scope.incrementSeconds = function () {
        if (!$scope.noIncrementSeconds()) {
            addSecondsToSelected(secondStep);
        }
    };

    $scope.decrementSeconds = function () {
        if (!$scope.noDecrementSeconds()) {
            addSecondsToSelected(-secondStep);
        }
    };

    $scope.toggleMeridian = function () {
        var minutes = getMinutesFromTemplate(),
            hours = getHoursFromTemplate();

        if (!$scope.noToggleMeridian()) {
            if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
            } else {
                $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
            }
        }
    };

    $scope.blur = function () {
        ngModelCtrl.$setTouched();
    };
}])

.directive('uibTimepicker', function () {
    return {
        require: ['uibTimepicker', '?^ngModel'],
        controller: 'UibTimepickerController',
        controllerAs: 'timepicker',
        replace: true,
        scope: {},
        templateUrl: function (element, attrs) {
            return attrs.templateUrl || 'uib/template/timepicker/timepicker.html';
        },
        link: function (scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

            if (ngModelCtrl) {
                timepickerCtrl.init(ngModelCtrl, element.find('input'));
            }
        }
    };
});

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('uibTypeaheadParser', ['$parse', function ($parse) {
      //                      00000111000000000000022200000000000000003333333333333330000000000044000
      var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
      return {
          parse: function (input) {
              var match = input.match(TYPEAHEAD_REGEXP);
              if (!match) {
                  throw new Error(
                    'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
                      ' but got "' + input + '".');
              }

              return {
                  itemName: match[3],
                  source: $parse(match[4]),
                  viewMapper: $parse(match[2] || match[1]),
                  modelMapper: $parse(match[1])
              };
          }
      };
  }])

  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',
    function (originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
        var HOT_KEYS = [9, 13, 27, 38, 40];
        var eventDebounceTime = 200;
        var modelCtrl, ngModelOptions;
        //SUPPORTED ATTRIBUTES (OPTIONS)

        //minimal no of characters that needs to be entered before typeahead kicks-in
        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
        if (!minLength && minLength !== 0) {
            minLength = 1;
        }

        //minimal wait time after last character typed before typeahead kicks-in
        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

        //should it restrict model values to the ones selected from the popup only?
        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
        originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
            isEditable = newVal !== false;
        });

        //binding to a variable that indicates if matches are being retrieved asynchronously
        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

        //a callback executed when a match is selected
        var onSelectCallback = $parse(attrs.typeaheadOnSelect);

        //should it select highlighted popup value when losing focus?
        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

        //binding to a variable that indicates if there were no results after the query is completed
        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

        var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

        var appendTo = attrs.typeaheadAppendTo ?
          originalScope.$eval(attrs.typeaheadAppendTo) : null;

        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

        //If input matches an item of the list exactly, select it automatically
        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

        //binding to a variable that indicates if dropdown is open
        var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;

        var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;

        //INTERNAL VARIABLES

        //model setter executed upon match selection
        var parsedModel = $parse(attrs.ngModel);
        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
        var $setModelValue = function (scope, newValue) {
            if (angular.isFunction(parsedModel(originalScope)) &&
              ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
                return invokeModelSetter(scope, { $$$p: newValue });
            }

            return parsedModel.assign(scope, newValue);
        };

        //expressions used by typeahead
        var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

        var hasFocus;

        //Used to avoid bug in iOS webview where iOS keyboard does not fire
        //mousedown & mouseup events
        //Issue #3699
        var selected;

        //create a child scope for the typeahead directive so we are not polluting original scope
        //with typeahead-specific data (matches, query etc.)
        var scope = originalScope.$new();
        var offDestroy = originalScope.$on('$destroy', function () {
            scope.$destroy();
        });
        scope.$on('$destroy', offDestroy);

        // WAI-ARIA
        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
        element.attr({
            'aria-autocomplete': 'list',
            'aria-expanded': false,
            'aria-owns': popupId
        });

        var inputsContainer, hintInputElem;
        //add read-only input to show hint
        if (showHint) {
            inputsContainer = angular.element('<div></div>');
            inputsContainer.css('position', 'relative');
            element.after(inputsContainer);
            hintInputElem = element.clone();
            hintInputElem.attr('placeholder', '');
            hintInputElem.val('');
            hintInputElem.css({
                'position': 'absolute',
                'top': '0px',
                'left': '0px',
                'border-color': 'transparent',
                'box-shadow': 'none',
                'opacity': 1,
                'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
                'color': '#999'
            });
            element.css({
                'position': 'relative',
                'vertical-align': 'top',
                'background-color': 'transparent'
            });
            inputsContainer.append(hintInputElem);
            hintInputElem.after(element);
        }

        //pop-up element used to display matches
        var popUpEl = angular.element('<div uib-typeahead-popup></div>');
        popUpEl.attr({
            id: popupId,
            matches: 'matches',
            active: 'activeIdx',
            select: 'select(activeIdx, evt)',
            'move-in-progress': 'moveInProgress',
            query: 'query',
            position: 'position',
            'assign-is-open': 'assignIsOpen(isOpen)',
            debounce: 'debounceUpdate'
        });
        //custom item template
        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
            popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
        }

        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
            popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
        }

        var resetHint = function () {
            if (showHint) {
                hintInputElem.val('');
            }
        };

        var resetMatches = function () {
            scope.matches = [];
            scope.activeIdx = -1;
            element.attr('aria-expanded', false);
            resetHint();
        };

        var getMatchId = function (index) {
            return popupId + '-option-' + index;
        };

        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
        // This attribute is added or removed automatically when the `activeIdx` changes.
        scope.$watch('activeIdx', function (index) {
            if (index < 0) {
                element.removeAttr('aria-activedescendant');
            } else {
                element.attr('aria-activedescendant', getMatchId(index));
            }
        });

        var inputIsExactMatch = function (inputValue, index) {
            if (scope.matches.length > index && inputValue) {
                return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
            }

            return false;
        };

        var getMatchesAsync = function (inputValue, evt) {
            var locals = { $viewValue: inputValue };
            isLoadingSetter(originalScope, true);
            isNoResultsSetter(originalScope, false);
            $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
                //it might happen that several async queries were in progress if a user were typing fast
                //but we are interested only in responses that correspond to the current view value
                var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                if (onCurrentRequest && hasFocus) {
                    if (matches && matches.length > 0) {
                        scope.activeIdx = focusFirst ? 0 : -1;
                        isNoResultsSetter(originalScope, false);
                        scope.matches.length = 0;

                        //transform labels
                        for (var i = 0; i < matches.length; i++) {
                            locals[parserResult.itemName] = matches[i];
                            scope.matches.push({
                                id: getMatchId(i),
                                label: parserResult.viewMapper(scope, locals),
                                model: matches[i]
                            });
                        }

                        scope.query = inputValue;
                        //position pop-up with matches - we need to re-calculate its position each time we are opening a window
                        //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
                        //due to other elements being rendered
                        recalculatePosition();

                        element.attr('aria-expanded', true);

                        //Select the single remaining option if user input matches
                        if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                $$debounce(function () {
                                    scope.select(0, evt);
                                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                            } else {
                                scope.select(0, evt);
                            }
                        }

                        if (showHint) {
                            var firstLabel = scope.matches[0].label;
                            if (inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                            }
                            else {
                                hintInputElem.val('');
                            }
                        }
                    } else {
                        resetMatches();
                        isNoResultsSetter(originalScope, true);
                    }
                }
                if (onCurrentRequest) {
                    isLoadingSetter(originalScope, false);
                }
            }, function () {
                resetMatches();
                isLoadingSetter(originalScope, false);
                isNoResultsSetter(originalScope, true);
            });
        };

        // bind events only if appendToBody params exist - performance feature
        if (appendToBody) {
            angular.element($window).on('resize', fireRecalculating);
            $document.find('body').on('scroll', fireRecalculating);
        }

        // Declare the debounced function outside recalculating for
        // proper debouncing
        var debouncedRecalculate = $$debounce(function () {
            // if popup is visible
            if (scope.matches.length) {
                recalculatePosition();
            }

            scope.moveInProgress = false;
        }, eventDebounceTime);

        // Default progress type
        scope.moveInProgress = false;

        function fireRecalculating() {
            if (!scope.moveInProgress) {
                scope.moveInProgress = true;
                scope.$digest();
            }

            debouncedRecalculate();
        }

        // recalculate actual position and set new values to scope
        // after digest loop is popup in right position
        function recalculatePosition() {
            scope.position = appendToBody ? $position.offset(element) : $position.position(element);
            scope.position.top += element.prop('offsetHeight');
        }

        //we need to propagate user's query so we can higlight matches
        scope.query = undefined;

        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
        var timeoutPromise;

        var scheduleSearchWithTimeout = function (inputValue) {
            timeoutPromise = $timeout(function () {
                getMatchesAsync(inputValue);
            }, waitTime);
        };

        var cancelPreviousTimeout = function () {
            if (timeoutPromise) {
                $timeout.cancel(timeoutPromise);
            }
        };

        resetMatches();

        scope.assignIsOpen = function (isOpen) {
            isOpenSetter(originalScope, isOpen);
        };

        scope.select = function (activeIdx, evt) {
            //called from within the $digest() cycle
            var locals = {};
            var model, item;

            selected = true;
            locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
            model = parserResult.modelMapper(originalScope, locals);
            $setModelValue(originalScope, model);
            modelCtrl.$setValidity('editable', true);
            modelCtrl.$setValidity('parse', true);

            onSelectCallback(originalScope, {
                $item: item,
                $model: model,
                $label: parserResult.viewMapper(originalScope, locals),
                $event: evt
            });

            resetMatches();

            //return focus to the input element if a match was selected via a mouse click event
            // use timeout to avoid $rootScope:inprog error
            if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
                $timeout(function () { element[0].focus(); }, 0, false);
            }
        };

        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
        element.on('keydown', function (evt) {
            //typeahead is open and an "interesting" key was pressed
            if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                return;
            }

            // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
            if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
                resetMatches();
                scope.$digest();
                return;
            }

            evt.preventDefault();

            switch (evt.which) {
                case 9:
                case 13:
                    scope.$apply(function () {
                        if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                            $$debounce(function () {
                                scope.select(scope.activeIdx, evt);
                            }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                        } else {
                            scope.select(scope.activeIdx, evt);
                        }
                    });
                    break;
                case 27:
                    evt.stopPropagation();

                    resetMatches();
                    scope.$digest();
                    break;
                case 38:
                    scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
                    scope.$digest();
                    popUpEl.find('li')[scope.activeIdx].scrollIntoView(false);
                    break;
                case 40:
                    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                    scope.$digest();
                    popUpEl.find('li')[scope.activeIdx].scrollIntoView(false);
                    break;
            }
        });

        element.bind('focus', function (evt) {
            hasFocus = true;
            if (minLength === 0 && !modelCtrl.$viewValue) {
                $timeout(function () {
                    getMatchesAsync(modelCtrl.$viewValue, evt);
                }, 0);
            }
        });

        element.bind('blur', function (evt) {
            if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
                selected = true;
                scope.$apply(function () {
                    if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
                        $$debounce(function () {
                            scope.select(scope.activeIdx, evt);
                        }, scope.debounceUpdate.blur);
                    } else {
                        scope.select(scope.activeIdx, evt);
                    }
                });
            }
            if (!isEditable && modelCtrl.$error.editable) {
                modelCtrl.$viewValue = '';
                element.val('');
            }
            hasFocus = false;
            selected = false;
        });

        // Keep reference to click handler to unbind it.
        var dismissClickHandler = function (evt) {
            // Issue #3973
            // Firefox treats right click as a click on document
            if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
                resetMatches();
                if (!$rootScope.$$phase) {
                    scope.$digest();
                }
            }
        };

        $document.on('click', dismissClickHandler);

        originalScope.$on('$destroy', function () {
            $document.off('click', dismissClickHandler);
            if (appendToBody || appendTo) {
                $popup.remove();
            }

            if (appendToBody) {
                angular.element($window).off('resize', fireRecalculating);
                $document.find('body').off('scroll', fireRecalculating);
            }
            // Prevent jQuery cache memory leak
            popUpEl.remove();

            if (showHint) {
                inputsContainer.remove();
            }
        });

        var $popup = $compile(popUpEl)(scope);

        if (appendToBody) {
            $document.find('body').append($popup);
        } else if (appendTo) {
            angular.element(appendTo).eq(0).append($popup);
        } else {
            element.after($popup);
        }

        this.init = function (_modelCtrl, _ngModelOptions) {
            modelCtrl = _modelCtrl;
            ngModelOptions = _ngModelOptions;

            scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);

            //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
            //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
            modelCtrl.$parsers.unshift(function (inputValue) {
                hasFocus = true;

                if (minLength === 0 || inputValue && inputValue.length >= minLength) {
                    if (waitTime > 0) {
                        cancelPreviousTimeout();
                        scheduleSearchWithTimeout(inputValue);
                    } else {
                        getMatchesAsync(inputValue);
                    }
                } else {
                    isLoadingSetter(originalScope, false);
                    cancelPreviousTimeout();
                    resetMatches();
                }

                if (isEditable) {
                    return inputValue;
                }

                if (!inputValue) {
                    // Reset in case user had typed something previously.
                    modelCtrl.$setValidity('editable', true);
                    return null;
                }

                modelCtrl.$setValidity('editable', false);
                return undefined;
            });

            modelCtrl.$formatters.push(function (modelValue) {
                var candidateViewValue, emptyViewValue;
                var locals = {};

                // The validity may be set to false via $parsers (see above) if
                // the model is restricted to selected values. If the model
                // is set manually it is considered to be valid.
                if (!isEditable) {
                    modelCtrl.$setValidity('editable', true);
                }

                if (inputFormatter) {
                    locals.$model = modelValue;
                    return inputFormatter(originalScope, locals);
                }

                //it might happen that we don't have enough info to properly render input value
                //we need to check for this situation and simply return model value if we can't apply custom formatting
                locals[parserResult.itemName] = modelValue;
                candidateViewValue = parserResult.viewMapper(originalScope, locals);
                locals[parserResult.itemName] = undefined;
                emptyViewValue = parserResult.viewMapper(originalScope, locals);

                return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
            });
        };
    }])

  .directive('uibTypeahead', function () {
      return {
          controller: 'UibTypeaheadController',
          require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
          link: function (originalScope, element, attrs, ctrls) {
              ctrls[2].init(ctrls[0], ctrls[1]);
          }
      };
  })

  .directive('uibTypeaheadPopup', ['$$debounce', function ($$debounce) {
      return {
          scope: {
              matches: '=',
              query: '=',
              active: '=',
              position: '&',
              moveInProgress: '=',
              select: '&',
              assignIsOpen: '&',
              debounce: '&'
          },
          replace: true,
          templateUrl: function (element, attrs) {
              return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
          },
          link: function (scope, element, attrs) {
              scope.templateUrl = attrs.templateUrl;

              scope.isOpen = function () {
                  var isDropdownOpen = scope.matches.length > 0;
                  scope.assignIsOpen({ isOpen: isDropdownOpen });
                  return isDropdownOpen;
              };

              scope.isActive = function (matchIdx) {
                  return scope.active === matchIdx;
              };

              scope.selectActive = function (matchIdx) {
                  scope.active = matchIdx;
              };

              scope.selectMatch = function (activeIdx, evt) {
                  var debounce = scope.debounce();
                  if (angular.isNumber(debounce) || angular.isObject(debounce)) {
                      $$debounce(function () {
                          scope.select({ activeIdx: activeIdx, evt: evt });
                      }, angular.isNumber(debounce) ? debounce : debounce['default']);
                  } else {
                      scope.select({ activeIdx: activeIdx, evt: evt });
                  }
              };
          }
      };
  }])

  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function ($templateRequest, $compile, $parse) {
      return {
          scope: {
              index: '=',
              match: '=',
              query: '='
          },
          link: function (scope, element, attrs) {
              var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
              $templateRequest(tplUrl).then(function (tplContent) {
                  var tplEl = angular.element(tplContent.trim());
                  element.replaceWith(tplEl);
                  $compile(tplEl)(scope);
              });
          }
      };
  }])

  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function ($sce, $injector, $log) {
      var isSanitizePresent;
      isSanitizePresent = $injector.has('$sanitize');

      function escapeRegexp(queryToEscape) {
          // Regex: capture the whole query string and replace it with the string that will be used to match
          // the results, for example if the capture is "a" the result will be \a
          return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
      }

      function containsHtml(matchItem) {
          return /<.*>/g.test(matchItem);
      }

      return function (matchItem, query) {
          if (!isSanitizePresent && containsHtml(matchItem)) {
              $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
          }
          matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
          if (!isSanitizePresent) {
              matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
          }
          return matchItem;
      };
  }]);

angular.module("uib/template/accordion/accordion-group.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/accordion/accordion-group.html",
      "<div class=\"panel\" ng-class=\"panelClass || 'panel-default'\">\n" +
      "  <div class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
      "    <h4 class=\"panel-title\">\n" +
      "      <div tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></div>\n" +
      "    </h4>\n" +
      "  </div>\n" +
      "  <div class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
      "	  <div class=\"panel-body\" ng-transclude></div>\n" +
      "  </div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/accordion/accordion.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/accordion/accordion.html",
      "<div class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("uib/template/alert/alert.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/alert/alert.html",
      "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" +
      "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
      "        <span aria-hidden=\"true\">&times;</span>\n" +
      "        <span class=\"sr-only\">Close</span>\n" +
      "    </button>\n" +
      "    <div ng-transclude></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/carousel/carousel.html",
      "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
      "  <div class=\"carousel-inner\" ng-transclude></div>\n" +
      "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\n" +
      "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
      "    <span class=\"sr-only\">previous</span>\n" +
      "  </a>\n" +
      "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\n" +
      "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
      "    <span class=\"sr-only\">next</span>\n" +
      "  </a>\n" +
      "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
      "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
      "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
      "    </li>\n" +
      "  </ol>\n" +
      "</div>");
}]);

angular.module("uib/template/carousel/slide.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/carousel/slide.html",
      "<div ng-class=\"{\n" +
      "    'active': active\n" +
      "  }\" class=\"item text-center\" ng-transclude></div>\n" +
      "");
}]);

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html",
      "<div class=\"uib-datepicker\" ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
      "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" +
      "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" +
      "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" +
      "</div>");
}]);

angular.module("template/datepicker/day.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/day.html",
      "<table class=\"uib-daypicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
      "  <thead>\n" +
      "    <tr>\n" +
      "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
      "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
      "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
      "    </tr>\n" +
      "    <tr>\n" +
      "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
      "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
      "    </tr>\n" +
      "  </thead>\n" +
      "  <tbody>\n" +
      "    <tr class=\"uib-weeks\" ng-repeat=\"row in rows track by $index\">\n" +
      "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
      "      <td ng-repeat=\"dt in row\" class=\"uib-day text-center\" role=\"gridcell\"\n" +
      "        id=\"{{::dt.uid}}\"\n" +
      "        ng-class=\"::dt.customClass\">\n" +
      "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default btn-sm\"\n" +
      "          uib-is-class=\"\n" +
      "            'btn-info' for selectedDt,\n" +
      "            'active' for activeDt\n" +
      "            on dt\"\n" +
      "          ng-click=\"select(dt.date)\"\n" +
      "          ng-disabled=\"::dt.disabled\"\n" +
      "          tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
      "      </td>\n" +
      "    </tr>\n" +
      "  </tbody>\n" +
      "</table>\n" +
      "");
}]);

angular.module("template/datepicker/month.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/month.html",
      "<table class=\"uib-monthpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
      "  <thead>\n" +
      "    <tr>\n" +
      "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
      "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
      "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
      "    </tr>\n" +
      "  </thead>\n" +
      "  <tbody>\n" +
      "    <tr class=\"uib-months\" ng-repeat=\"row in rows track by $index\">\n" +
      "      <td ng-repeat=\"dt in row\" class=\"uib-month text-center\" role=\"gridcell\"\n" +
      "        id=\"{{::dt.uid}}\"\n" +
      "        ng-class=\"::dt.customClass\">\n" +
      "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\"\n" +
      "          uib-is-class=\"\n" +
      "            'btn-info' for selectedDt,\n" +
      "            'active' for activeDt\n" +
      "            on dt\"\n" +
      "          ng-click=\"select(dt.date)\"\n" +
      "          ng-disabled=\"::dt.disabled\"\n" +
      "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
      "      </td>\n" +
      "    </tr>\n" +
      "  </tbody>\n" +
      "</table>\n" +
      "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/popup.html",
      "<ul class=\"uib-datepicker-popup dropdown-menu\" dropdown-nested ng-if=\"isOpen\" style=\"display: block\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
      "	<li ng-transclude></li>\n" +
      "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\" class=\"uib-button-bar\">\n" +
      "		<span class=\"btn-group pull-left\">\n" +
      "			<button type=\"button\" class=\"btn btn-sm btn-info uib-datepicker-current\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
      "			<button type=\"button\" class=\"btn btn-sm btn-danger uib-clear\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
      "		</span>\n" +
      "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right uib-close\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
      "	</li>\n" +
      "</ul>\n" +
      "");
}]);

angular.module("template/datepicker/year.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/year.html",
      "<table class=\"uib-yearpicker\" role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
      "  <thead>\n" +
      "    <tr>\n" +
      "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left uib-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
      "      <th colspan=\"{{::columns - 2}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm uib-title\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
      "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right uib-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
      "    </tr>\n" +
      "  </thead>\n" +
      "  <tbody>\n" +
      "    <tr class=\"uib-years\" ng-repeat=\"row in rows track by $index\">\n" +
      "      <td ng-repeat=\"dt in row\" class=\"uib-year text-center\" role=\"gridcell\"\n" +
      "        id=\"{{::dt.uid}}\"\n" +
      "        ng-class=\"::dt.customClass\">\n" +
      "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\"\n" +
      "          uib-is-class=\"\n" +
      "            'btn-info' for selectedDt,\n" +
      "            'active' for activeDt\n" +
      "            on dt\"\n" +
      "          ng-click=\"select(dt.date)\"\n" +
      "          ng-disabled=\"::dt.disabled\"\n" +
      "          tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
      "      </td>\n" +
      "    </tr>\n" +
      "  </tbody>\n" +
      "</table>\n" +
      "");
}]);

angular.module("uib/template/modal/backdrop.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/modal/backdrop.html",
      "<div class=\"modal-backdrop\"\n" +
      "     uib-modal-animation-class=\"fade\"\n" +
      "     modal-in-class=\"in\"\n" +
      "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
      "></div>\n" +
      "");
}]);

angular.module("uib/template/modal/window.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/modal/window.html",
      "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
      "    uib-modal-animation-class=\"fade\"\n" +
      "    modal-in-class=\"in\"\n" +
      "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" +
      "    <div class=\"modal-dialog\" ng-class=\"size ? 'modal-' + size : ''\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/pager/pager.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/pager/pager.html",
      "<ul class=\"pager\">\n" +
      "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
      "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
      "</ul>\n" +
      "");
}]);

angular.module("uib/template/pagination/pager.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/pagination/pager.html",
      "<ul class=\"pager\">\n" +
      "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
      "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
      "</ul>\n" +
      "");
}]);

angular.module("uib/template/pagination/pagination.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/pagination/pagination.html",
      "<ul class=\"pagination\">\n" +
      "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" +
      "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
      "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
      "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
      "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" +
      "</ul>\n" +
      "");
}]);

angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-html-popup.html",
      "<div class=\"tooltip\"\n" +
      "  tooltip-animation-class=\"fade\"\n" +
      "  uib-tooltip-classes\n" +
      "  ng-class=\"{ in: isOpen() }\">\n" +
      "  <div class=\"tooltip-arrow\"></div>\n" +
      "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/tooltip/tooltip-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-popup.html",
      "<div class=\"tooltip\"\n" +
      "  tooltip-animation-class=\"fade\"\n" +
      "  uib-tooltip-classes\n" +
      "  ng-class=\"{ in: isOpen() }\">\n" +
      "  <div class=\"tooltip-arrow\"></div>\n" +
      "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-template-popup.html",
      "<div class=\"tooltip\"\n" +
      "  tooltip-animation-class=\"fade\"\n" +
      "  uib-tooltip-classes\n" +
      "  ng-class=\"{ in: isOpen() }\">\n" +
      "  <div class=\"tooltip-arrow\"></div>\n" +
      "  <div class=\"tooltip-inner\"\n" +
      "    uib-tooltip-template-transclude=\"contentExp()\"\n" +
      "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/popover/popover-html.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/popover/popover-html.html",
      "<div class=\"popover\"\n" +
      "  tooltip-animation-class=\"fade\"\n" +
      "  uib-tooltip-classes\n" +
      "  ng-class=\"{ in: isOpen() }\">\n" +
      "  <div class=\"arrow\"></div>\n" +
      "\n" +
      "  <div class=\"popover-inner\">\n" +
      "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
      "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
      "  </div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/popover/popover-template.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/popover/popover-template.html",
      "<div class=\"popover\"\n" +
      "  tooltip-animation-class=\"fade\"\n" +
      "  uib-tooltip-classes\n" +
      "  ng-class=\"{ in: isOpen() }\">\n" +
      "  <div class=\"arrow\"></div>\n" +
      "\n" +
      "  <div class=\"popover-inner\">\n" +
      "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
      "      <div class=\"popover-content\"\n" +
      "        uib-tooltip-template-transclude=\"contentExp()\"\n" +
      "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
      "  </div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/popover/popover.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/popover/popover.html",
      "<div class=\"popover\"\n" +
      "  tooltip-animation-class=\"fade\"\n" +
      "  uib-tooltip-classes\n" +
      "  ng-class=\"{ in: isOpen() }\">\n" +
      "  <div class=\"arrow\"></div>\n" +
      "\n" +
      "  <div class=\"popover-inner\">\n" +
      "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
      "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
      "  </div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/progressbar/bar.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/progressbar/bar.html",
      "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
      "");
}]);

angular.module("uib/template/progressbar/progress.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/progressbar/progress.html",
      "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
}]);

angular.module("uib/template/progressbar/progressbar.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/progressbar/progressbar.html",
      "<div class=\"progress\">\n" +
      "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" ng-transclude></div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/rating/rating.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/rating/rating.html",
      "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" +
      "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
      "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\" aria-valuetext=\"{{r.title}}\"></i>\n" +
      "</span>\n" +
      "");
}]);

angular.module("template/tabs/tab.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/tab.html",
      "<li ng-class=\"{active: active, disabled: disabled}\" class=\"uib-tab\">\n" +
      "  <a href='' ng-click=\"select()\" uib-tab-heading-transclude>{{heading}}</a>\n" +
      "</li>\n" +
      "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/tabset.html",
      "<div>\n" +
      "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
      "  <div class=\"tab-content\">\n" +
      "    <div class=\"tab-pane\" \n" +
      "         ng-repeat=\"tab in tabs\" \n" +
      "         ng-class=\"{active: tab.active}\"\n" +
      "         uib-tab-content-transclude=\"tab\">\n" +
      "    </div>\n" +
      "  </div>\n" +
      "</div>\n" +
      "");
}]);

angular.module("uib/template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/timepicker/timepicker.html",
      "<table class=\"uib-timepicker\">\n" +
      "  <tbody>\n" +
      "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
      "      <td class=\"uib-increment hours\"><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
      "      <td>&nbsp;</td>\n" +
      "      <td class=\"uib-increment minutes\"><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
      "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
      "      <td ng-show=\"showSeconds\" class=\"uib-increment seconds\"><a ng-click=\"incrementSeconds()\" ng-class=\"{disabled: noIncrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
      "      <td ng-show=\"showMeridian\"></td>\n" +
      "    </tr>\n" +
      "    <tr>\n" +
      "      <td class=\"form-group uib-time hours\" ng-class=\"{'has-error': invalidHours}\">\n" +
      "        <input style=\"width:50px;\" type=\"text\" placeholder=\"HH\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"disabled\" ng-blur=\"blur()\">\n" +
      "      </td>\n" +
      "      <td class=\"uib-separator\">:</td>\n" +
      "      <td class=\"form-group uib-time minutes\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
      "        <input style=\"width:50px;\" type=\"text\" placeholder=\"MM\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"disabled\" ng-blur=\"blur()\">\n" +
      "      </td>\n" +
      "      <td ng-show=\"showSeconds\" class=\"uib-separator\">:</td>\n" +
      "      <td class=\"form-group uib-time seconds\" ng-class=\"{'has-error': invalidSeconds}\" ng-show=\"showSeconds\">\n" +
      "        <input style=\"width:50px;\" type=\"text\" ng-model=\"seconds\" ng-change=\"updateSeconds()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\" ng-disabled=\"disabled\" ng-blur=\"blur()\">\n" +
      "      </td>\n" +
      "      <td ng-show=\"showMeridian\" class=\"uib-time am-pm\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
      "    </tr>\n" +
      "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
      "      <td class=\"uib-decrement hours\"><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
      "      <td>&nbsp;</td>\n" +
      "      <td class=\"uib-decrement minutes\"><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
      "      <td ng-show=\"showSeconds\">&nbsp;</td>\n" +
      "      <td ng-show=\"showSeconds\" class=\"uib-decrement seconds\"><a ng-click=\"decrementSeconds()\" ng-class=\"{disabled: noDecrementSeconds()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementSeconds()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
      "      <td ng-show=\"showMeridian\"></td>\n" +
      "    </tr>\n" +
      "  </tbody>\n" +
      "</table>\n" +
      "");
}]);

angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-match.html",
      "<a href tabindex=\"-1\" ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"></a>\n" +
      "");
}]);

angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-popup.html",
      "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
      "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index, $event)\" role=\"option\" id=\"{{::match.id}}\">\n" +
      "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
      "    </li>\n" +
      "</ul>\n" +
      "");
}]);
angular.module('ui.bootstrap.carousel').run(function () { !angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); })